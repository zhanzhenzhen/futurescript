<!DOCTYPE html>
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>FutureScript 2.4.0</title>
    <link rel="stylesheet" href="base.css" type="text/css" />
    <style type="text/css"><![CDATA[
        html {
            font-size: 13pt;
        }
        body {
            width: 900px;
        }
        table.table {
            border-collapse: collapse;
        }
        table.table, table.table td, table.table th {
            border: 1px solid black;
        }
        td, th {
            vertical-align: top;
            text-align: left;
        }
        code {
            font-size: 0.9rem;
        }
        p > code, li > code {
            background-color: rgb(224,224,224);
            padding-left: 0.2em;
            padding-right: 0.2em;
        }
        pre {
            border-left: 0.6em solid rgb(224,224,224);
            padding: 0.25em 1em;
        }
        .warning {
            background-color: rgb(255,192,192);
        }
        .detail {
            font-family: STKaiti, KaiTi;
            font-size: 0.95rem;
            color: rgb(144,144,144);
        }
        .question {
            text-decoration: underline;
        }
        .try {
            display: none;
        }
        .column-center td, .column-center th {
            text-align: center;
        }
        .first-column-left td:first-child, .first-column-left th:first-child {
            text-align: left;
        }
        .first-column-right td:first-child, .first-column-right th:first-child {
            text-align: right;
        }
    ]]></style>
    <script src="doc-html.js" type="text/javascript" />
</head>
<body>
<pre class="try"><code class="fus"><![CDATA[
    fus 2.4.0

    ..: <> require("lodash")

    # Dot-dot symbol `..` means virtual method. It lets you use underscore or lodash
    # much easier.
    # So you can forget about `_()` and `.value()`.

    console.log [2, 3, 4]..max()

    console.log [5, 3, [2, 4], 1]..flatten()..sortBy()

    # Diamond function `<>` is parameterless. But ignore it at the moment. Run the code
    # and view the 2nd example.
    # The 2nd example will tell you what `:` and `=` mean.

]]></code></pre>
<pre class="try"><code class="fus"><![CDATA[
    fus 2.4.0

    # Forget about the annoying == and ===. Equals sign `=` means equal.
    a: 3 # Colon `:` outside braces `{}` means assignment.
    b: 3
    if a = b
        console.log "a is equal to b"

    # You can even use ≠ to mean inequality by holding "Alt" key then "=".
    # Don't believe? Try it in this editor.
    a: 3
    b: 4
    if a ≠ b
        console.log "a is not equal to b"
    if a /= b # /= also means inequality, which is the same as above.
        console.log "a is really not equal to b"

    c: 3
    if 1 ≤ c ≤ 5
        console.log "c is between 1 and 5"
    if 1 <= c <= 5
        console.log "c is really between 1 and 5"

    # Mac OS natively supports "Alt" + "=", "<" and ">". Windows users can customize
    # shortcut keys in editor, just like what we customized in this editor.
    # Some editors support inserting a snippet with Tab, so you can set "="+"Tab".

]]></code></pre>
<pre class="try"><code class="fus"><![CDATA[
    fus 2.4.0
    import "./manifest" all

    # Asynchronous function
    do <>
        q: encodeURIComponent("
            select * from yahoo.finance.quotes where symbol in ("AAPL")
        ")
        env: encodeURIComponent("store://datatables.org/alltableswithkeys")
        query: "?q=\(q)&env=\(env)&format=json"

        console.log "Querying stock price..."

        response: web.jsonGet("https://query.yahooapis.com/v1/public/yql\(query)")'wait
        quote: response.body.query.results.quote

        console.log "Apple Inc. Bid: \(quote.Bid), Ask: \(quote.Ask)"

    # Forget about the "Triangle of Doom".
    # Just add a `'wait` to a promise. It will wait until a response is received.
    # The function that contains `'wait` automatically becomes an async function.
    # There's no callback, just like all synchronous things.

    # `do` means to call the function itself.

]]></code></pre>
<pre class="try"><code class="fus"><![CDATA[
    fus 2.4.0

    # Pattern matching could be regarded as an enhanced "switch", except that
    # it's an expression rather than a command so it's functional.
    day: 3
    text: match day
        1 ? "Mon"
        2 ? "Tue"
        3 ? "Wed"
        4 ? "Thu"
        5 ? "Fri"
        6 ? "Sat"
        |   "Sun"
    console.log text

]]></code></pre>
<pre class="try"><code class="fus"><![CDATA[
    fus 2.4.0

    a: {}
    console.log(a is Object) # a instanceof Object

    a: 1
    console.log(a is Number) # typeof a === "number"

    # `is` compiles differently based on whether it's followed by a
    # primitive type. It's a combination of `instanceof` and `typeof`.

]]></code></pre>
<pre class="try"><code class="fus"><![CDATA[
    fus 2.4.0

    # Array's index is actually a property. Don't believe? Type it in JS console:
    # a=[12,34]
    # Object.keys(a)
    # You'll find two properties "0" and "1". That's why JS's a[0] is equivalent to
    # a["0"]. And a["0"] is actually its "normative" form.

    # But JS's [] itself is inconsistent. e.g. [12, 34] means an array while a[0] means
    # element access. It's far from perfect. A future language should aim to be perfect.
    # We know array is an object with index being property. So we use "." to access.

    a: [12, 34]
    console.log(a.0, a.1) # console.log(a[0], a[1])

    a: {"long prop": 777}
    console.log a."long prop" # console.log(a["long prop"])

    index: 1
    a: [12, 34, 56]
    console.log a.(index) # console.log(a[index])

    # This solution is consistent and concise. I bet you'll be attracted by its beauty.

    # In Fus, every syntax is extremely consistent. e.g. [] is array, {} is object, and
    # `:` means "let left be right" - the same as JSON, which is the best part of JS.

]]></code></pre>
<pre class="try"><code class="fus"><![CDATA[
    fus 2.4.0

    # Now that the syntax is consistent, function call will be not limited to ().

    console.log([12, 34, 56])
    console.log[12, 34, 56] # same as above, but more concise

    console.log({a: 1, b: 2})
    console.log{a: 1, b: 2} # same as above, but more concise

]]></code></pre>
<pre class="try"><code class="fus"><![CDATA[
    fus 2.4.0

    # Feel JS's `arguments` is too long? Fus provides `@`. You can even omit
    # the dot. `@0` is the same as `@.0`.
    # Diamond function <> is also parameterless. In <> you can use `@`.
    # @ is easy to remember. From now on you can pronounce @ as "arg".
    #
    add: <> @0 + @1 # var add = function() {return arguments[0] + arguments[1];};
    console.log add(2, 3)

    # `undefined` is also too long? No problem. Fus provides `void`.
    console.log void

    # In Fus, there's no keyword longer than 7 letters.

]]></code></pre>
<pre class="try"><code class="fus"><![CDATA[
    fus 2.4.0

    distance: point ->
        x: point.x
        y: point.y
        Math.sqrt(x * x + y * y)

    console.log distance{x: 3, y: 4}

    # Function doesn't need `return`. The last statement is the return value.

    # Variables don't need to be declared with `var`. They will be declared
    # automatically when first assigned. The scope is the function level.
    # It's concise and can avoid global pollution. In JS if you forget writing
    # `var` then it will become a global variable that results in global pollution.

    # You can strip the # in the next line and see what error it shows.
    #console.log x

]]></code></pre>
<pre class="try"><code class="fus"><![CDATA[
    fus 2.4.0

    Cat: class
        new: name ->
            me.name: name
            me._spoken: 0
        speak: <>
            me._spoken: self + 1
            console.log "\(me.name) meows for the \(me._spoken) time."

    # Instantiating a class doesn't require `new`. Fus will check it. If a callee
    # (here `Cat`) is capitalized, it will automatically add `new` in the compiled JS.
    cat: Cat("Dabai")
    cat.speak()
    cat.speak()

    console.log cat.name

    # If a class property name starts with `_`, it will be "private". So
    # `cat._spoken` is undefined.
    console.log cat._spoken

    # In essence, Fus class is just JS class. So you may well import Fus classes
    # in your JS file.

]]></code></pre>
<pre class="try"><code class="fus"><![CDATA[
    fus 2.4.0
    import "./manifest" all

    Color: enum{red, green, blue}

    console.log(Color.red, Color.green, Color.blue)

    # Flexible object (type-1) lets you achieve enum easily, while in essence it's
    # the return value of a function call that passes an object.
    # Don't believe? Just strip the # in the next line and see the output.
    #console.log{red, green, blue}

]]></code></pre>
<pre class="try"><code class="fus"><![CDATA[
    fus 2.4.0
    import "./manifest" all

    loop{1 to 5 for i ->
        console.log(i * i)
    }

    # Flexible object (type-2) can apply to `loop` function. It makes you close
    # to be able to customize grammars to write a beautiful loop, while in essence
    # it's still "an object is passed to a function".

    # Don't believe? Replace `loop` with `console.log` and see the output.
    # (Because the output is the converted JSON, you can't see the function.)

    # Using these 2 types of flexible objects together with "batch import",
    # everyone is close to have the power to extend this language.

]]></code></pre>
<p>Below are tutorial (shown in normal font), and detailed specification that may be uninteresting to developers (shown in gray, smaller font). On first time reading, you can just read the tutorial (tutorial is also part of the specification, though easier to understand).</p>
<h1>Less and More</h1>
<h2 class="unlinkable">More</h2>
<table class="table column-center first-column-left">
    <tr>
        <th style="width: 12em;"></th>
        <th>FutureScript</th>
        <th>JS (ES5)</th>
        <th>JS (ES6)</th>
        <th>CoffeeScript</th>
    </tr>
    <tr>
        <td id="to-358d4ea8-456b-473a-b2d2-8452aaaf4341">Async function</td>
        <td>✓</td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td id="to-13c8cdd4-8926-4fb8-af19-54ecf57ace68">Simplified function notation</td>
        <td>✓</td>
        <td></td>
        <td>✓</td>
        <td>✓</td>
    </tr>
    <tr>
        <td id="to-489b552b-f32e-42e7-84ee-c43e1100c4d3">Functional <code>if</code></td>
        <td>✓</td>
        <td></td>
        <td></td>
        <td>✓</td>
    </tr>
    <tr>
        <td id="to-45cf5b2b-c445-4018-b491-d3c46f61aa50">Simplified <code>if</code></td>
        <td>✓</td>
        <td>✓</td>
        <td>✓</td>
        <td></td>
    </tr>
    <tr>
        <td id="to-f79a8657-a1a6-42d6-a2ff-fbb5782ae2c5">Pattern matching</td>
        <td>✓</td>
        <td></td>
        <td></td>
        <td>✓ partial</td>
    </tr>
    <tr>
        <td id="to-07f8b8dd-4758-4796-96bf-7e5c18b0adf8">Complex self-assignment</td>
        <td>✓</td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td id="to-45c16ac3-746a-489e-9fd9-be4044b79691">Anonymous recursion</td>
        <td>✓</td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td id="to-9cb14d0e-24e4-4cc1-8ef3-f7318845e58b">Instantiating a class doesn't require <code>new</code></td>
        <td>✓</td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td id="to-652ac57c-8042-442d-aaa3-8152fe86836f">Class private properties</td>
        <td>✓</td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td id="to-70259430-cb80-46c7-b662-ef56643820a3">Class getter, setter</td>
        <td>✓</td>
        <td></td>
        <td>✓</td>
        <td></td>
    </tr>
    <tr>
        <td id="to-9861d8b0-8d40-4504-8408-80d9d557cdf0">Class static constructor</td>
        <td>✓</td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td id="to-1619f159-69e3-48ae-acb5-ff258e2c3c37">Current class</td>
        <td>✓</td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td id="to-0262e17a-facd-431e-94c8-2779b4c9ab0a">Pipe</td>
        <td>✓</td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td id="to-fd221fe8-2827-4c16-8947-b35900b3b050">Virtual method</td>
        <td>✓</td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td id="to-7f0551f5-957f-4921-ba69-1cabef57f5d8"><code>rem</code> modulo</td>
        <td>✓</td>
        <td>✓</td>
        <td>✓</td>
        <td>✓</td>
    </tr>
    <tr>
        <td id="to-9fac9a39-2e51-475c-aeb7-6dfebec74886"><code>mod</code> modulo</td>
        <td>✓</td>
        <td></td>
        <td></td>
        <td>✓</td>
    </tr>
    <tr>
        <td id="to-208ce2a3-d863-45af-81e1-5c2d573bd28e">Combine <code>instanceof</code> and <code>typeof</code></td>
        <td>✓</td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td id="to-c88a5a59-72cf-4778-b414-a5da92a89ec4">Import</td>
        <td>✓</td>
        <td></td>
        <td>✓</td>
        <td></td>
    </tr>
    <tr>
        <td id="to-28715698-580a-4a4d-b70c-91126bffa74b">Batch import</td>
        <td>✓</td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td id="to-e652b57f-7914-464d-b58d-d34eef33ab97">Export</td>
        <td>✓</td>
        <td></td>
        <td>✓</td>
        <td></td>
    </tr>
    <tr>
        <td id="to-1178787f-e307-4df2-9149-f0197bb762a3">String interpolation</td>
        <td>✓</td>
        <td></td>
        <td>✓</td>
        <td>✓</td>
    </tr>
    <tr>
        <td id="to-7e0f8522-9f6b-43e6-ae1b-d16025011688">Functional <code>try...catch</code></td>
        <td>✓</td>
        <td></td>
        <td></td>
        <td>✓</td>
    </tr>
    <tr>
        <td id="to-d32afece-1962-414d-9720-ccb039b55a72">Flexible object</td>
        <td>✓</td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td id="to-0a58dc19-117d-444a-93a3-f6ddef662118">Natural enum</td>
        <td>✓ via fus-ext</td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td id="to-4f86f72f-4e5f-4f17-89a1-fb5e48fd2eca">Natural functional loop</td>
        <td>✓ via fus-ext</td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td id="to-7122051a-71aa-45e4-9af3-79271969be81">Self-invoke</td>
        <td>✓</td>
        <td></td>
        <td></td>
        <td>✓</td>
    </tr>
    <tr>
        <td id="to-cc452c6d-d76a-4836-b9ff-0617b74d5d34">Existential operators</td>
        <td>✓</td>
        <td></td>
        <td></td>
        <td>✓</td>
    </tr>
    <tr>
        <td id="to-3d5383b2-f689-49fc-ad1f-693030300f9e">Membership operator</td>
        <td>✓</td>
        <td></td>
        <td></td>
        <td>✓</td>
    </tr>
    <tr>
        <td id="to-27423eb9-49f7-426a-9517-187a886a940f">Exponentiation operator</td>
        <td>✓</td>
        <td></td>
        <td></td>
        <td>✓</td>
    </tr>
</table>
<h2 class="unlinkable">Less</h2>
<p>These years, JS grammar is getting more and more complex, also more and more cumbersome.</p>
<table class="table column-center first-column-left">
    <tr>
        <th>JS</th>
        <th>FutureScript</th>
    </tr>
    <tr>
        <td>Three symbols to mean strings</td>
        <td>Unified to double quotes</td>
    </tr>
    <tr>
        <td><code>=</code> assignment</td>
        <td>Unified to colon</td>
    </tr>
    <tr>
        <td><code>[]</code> to access elements</td>
        <td>Unified to dot</td>
    </tr>
    <tr>
        <td>Native loop</td>
        <td>Implemented using flexible object</td>
    </tr>
    <tr>
        <td><code>return</code></td>
        <td></td>
    </tr>
    <tr>
        <td><code>someVar++</code></td>
        <td><code>someVar: self + 1</code></td>
    </tr>
    <tr>
        <td><code>someVar--</code></td>
        <td><code>someVar: self - 1</code></td>
    </tr>
    <tr>
        <td><code>someVar += 2</code></td>
        <td><code>someVar: self + 2</code></td>
    </tr>
    <tr>
        <td><code>someVar -= 2</code></td>
        <td><code>someVar: self - 2</code></td>
    </tr>
    <tr>
        <td><code>someVar *= 2</code></td>
        <td><code>someVar: self * 2</code></td>
    </tr>
    <tr>
        <td><code>someVar /= 2</code></td>
        <td><code>someVar: self / 2</code></td>
    </tr>
    <tr>
        <td><code>&lt;&lt;</code></td>
        <td></td>
    </tr>
    <tr>
        <td><code>&gt;&gt;</code></td>
        <td></td>
    </tr>
    <tr>
        <td><code>&gt;&gt;&gt;</code></td>
        <td></td>
    </tr>
</table>
<h2 class="unlinkable">Future Style</h2>
<p>FutureScript is the first language to have all of these 4 properties:</p>
<ul>
    <li>Version line</li>
    <li>Colon to assign</li>
    <li>Equals sign to mean equal</li>
    <li>Use dot instead of brackets to access to array element</li>
</ul>
<p>The author calls this set of properties "the future style".</p>
<p>Some of Fus's features, such as flexible object, have never be implemented by any language before.</p>
<p>Fus's target: We want to make it so that <b>any terser language isn't more readable than Fus, and any more readable language isn't terser than Fus</b>. We are finding the balance point of terseness and readability, while keeping its thrilling beauty and consistency.</p>
<h1>Usage</h1>
<p>(This chapter is not part of the language specification. Because tools will be updated in the future, this chapter may be out-of-date then.)</p>
<h2 class="unlinkable">Install</h2>
<p>First confirm you've installed Node.js 4.0 or higher on your computer (5.0 or higher the better).</p>
<pre><code><![CDATA[
    npm install -g futurescript
]]></code></pre>
<p>For detailed usage of <code>fus</code> command, please click:</p>
<p><a href="https://www.npmjs.com/package/futurescript">https://www.npmjs.com/package/futurescript</a></p>
<h2 class="unlinkable">Text Editor</h2>
<p>We provide syntax highlighting modules for text editors such as Sublime Text and Atom. I think it should also work on WebStorm and other editors that support tmbundle.</p>
<p>Atom users can use <a href="https://atom.io/packages/language-futurescript">language-futurescript</a> package. You can continue using your current theme, or use these 2 themes optimized for FutureScript: <a href="https://atom.io/themes/4-color">4-color</a> and <a href="https://atom.io/themes/4-color-dark">4-color-dark</a>.</p>
<p>For other editors, for example Sublime Text, in its menu choose Preferences, Browse Packages. The popped-up window is the directory containing all language packages. <a href="https://github.com/zhanzhenzhen/futurescript/releases">Click here to download</a> the latest version, then rename the "tmbundle" directory to "FutureScript". Then copy it to the "Packages" directory.</p>
<p>The syntax highlighting name we use is "FutureScript h1".</p>
<h1>Code Structure</h1>
<h2>File Appearance</h2>
<p>File extension is <code>.fus</code>.</p>
<p class="detail">Fus file appearance: comprises version line, statements, comments, and meaningless whitespaces. Statements can be nested. Version line and statements are meaningful. Comments and meaningless whitespaces are meaningless.</p>
<p class="detail">A statement is not an expression nor treated as expression. An expression is not a statement, but can be treated as statement (named as "expression statement"). There are 2 kinds of statements: expression statements and command statements.</p>
<p>Similar to CoffeeScript, in FutureScript, indents are important, for they form the nested structure. Indent can be substituted by <code>&lt;&lt;</code> and <code>&gt;&gt;</code>.</p>
<p>Similar to CoffeeScript, juxtaposed lines can be combined using semicolon<code>;</code>, and a single line can be splitted by using <code>\</code>.</p>
<p class="detail">Empty line, or blank line, means a line that doesn't have any character.</p>
<p class="detail">Whitespace line, means an empty line or a line that only have whitespaces.</p>
<p class="detail">Meaningless whitespace, means an empty line, or the whitespace that's meaningless in the right side of a line.</p>
<p class="detail">In all text hereinafter, we assume that meaningless whitespaces are removed.</p>
<p class="detail">Most statements are expression statements, except that these are command statements:</p>
<ul class="detail">
    <li>: (colon, when meaning assignment)</li>
    <li>delete</li>
    <li>import (excluding <code>import</code> expression)</li>
    <li>export (limited to <code>export</code> at the start of a statement, so excluding<code>export as</code>, but including<code>export...as</code>)</li>
    <li>throw</li>
    <li>pause</li>
</ul>
<p class="detail">Given a statement, the maximum consecutive content of the level of the statement is called the block of the statement. Block doesn't include version line. Besides block, there is list. Either block or list is called a "container". Block's child can be statement or comment. List's child can't be statement. A child block (or child list) of a statement means the first-level descendant of the statement. A child statement of a block also means first-level descendant.</p>
<p class="detail">These containers are blocks:</p>
<ul class="detail">
    <li>Root block</li>
    <li>Function block</li>
    <li><code>then</code> block</li>
    <li><code>else</code> block</li>
    <li><code>try</code> block</li>
    <li><code>catch</code> block</li>
    <li><code>finally</code> block</li>
</ul>
<p class="detail">All other containers are lists. For example:</p>
<ul class="detail">
    <li><code>class</code> list</li>
    <li>Array list</li>
    <li>Object list</li>
    <li><code>match</code> list</li>
</ul>
<p>If a block (except <code>catch</code> block) has only a single statement, it can be written in the same line without indent. This is called inline block. For example:</p>
<pre><code class="fus-part"><![CDATA[
    if x = 5 then aaa()
]]></code></pre>
<p class="detail">Note that <code>aaa()</code> still belongs to <code>then</code> block. Also note, that in this notation, there must be a corresponding keyword or symbol ahead of the block. In the above example the <code>then</code> can't be omitted. From this we know that every block (except that in post-if) has a leading keyword or symbol in grammar. For example, <code>-&gt;</code>, <code>then</code>, and<code>try</code>. It can be omitted only when it isn't at the start of a statement and isn't at the start of a line and isn't followed by an inline block (also depends on whether the grammar supports it. For example <code>-&gt;</code> can't be omitted).</p>
<p>Block's child statements are run from top to bottom. Except for the root block, every block has a value. If the last statement is an expression, then the value is the expression value, otherwise the value is <code>void</code>.</p>
<h2>Indent</h2>
<p class="detail">For a given line B, if the starting part doesn't belong to a string, what's the effect of its indent? Follow the following steps:</p>
<p class="detail">1. Force connect: Does the previous line A end with <code>\</code>? If not, do next step. If yes, then: No matter how much indent, the line is parsed as if connected to the end of last line, then skip to step 5. If failing to parse then skip to step 6. (Terminology: "connect" in these steps means concatenation of two lines with a space inserted between them. The indent of the second line doesn't count.)</p>
<p class="detail">2. Juxtaposition: In above code does there exist a line A satisfying that B's indent is equal to A's indent, and there's no line between A and B or the indent of any line between A and B is greater than B's indent, and A is not connected or force connected (Terminology: the "connected" one means the right-hand side after connect, while the "connector" means the left-hand side)? If not, do the next step. If yes, then: A's starting part and B's starting part is parsed as the "juxtaposition" relation, then skip to step 5. If failing to parse, skip to step 4.</p>
<p class="detail">3. Hierarchical: In above code does there exist a line A satisfying that B's indent is greater than A's indent, and there's no line between A and B or the indent of any line between A and B is greater than B's indent, and A is not connected or force connected? If not, do the next step. If yes, then: A's ending part and B's starting part is parsed as the "hierarchical" relation, then skip to step 5. If failing to parse, skip to step 4.</p>
<p class="detail">4. Connect: In above code does there exist a line A satisfying that B's indent is greater than or equal to A's indent, and there's no line between A and B or the indent of any line between A and B is greater than B's indent? If not, then skip to step 6. If yes, then: B is parsed as if it's connected to the end of the statement of A's end. If failing to parse, skip to step 6. For example:</p>
<pre><code class="fus-part"><![CDATA[
    if x = 5 and
    y = 5 then aaa()
]]></code></pre>
<p>Or:</p>
<pre><code class="fus-part"><![CDATA[
    if x = 5
    and y = 5 then aaa()
]]></code></pre>
<p>Or:</p>
<pre><code class="fus-part"><![CDATA[
    if x = 5 and
        y = 5 then aaa()
]]></code></pre>
<p>Both equivalent to:</p>
<pre><code class="fus-part"><![CDATA[
    if x = 5 and y = 5 then aaa()
]]></code></pre>
<p>Note that for now this is not supported:</p>
<pre><code class="fus-part"><![CDATA[
    a.b <>
        aaa()
    .c()
]]></code></pre>
<p>You need to add a parenthesis pair:</p>
<pre><code class="fus-part"><![CDATA[
    a.b(<>
        aaa()
    ).c()
]]></code></pre>
<p class="detail">5. Succeed and exit.</p>
<p class="detail">6. Fail and exit.</p>
<p>Indents are very suitable to represent some complex statement. For example, you can write:</p>
<pre><code class="fus-part"><![CDATA[
    text: "This is a dog."
    speak: match (<>
        s: @0.toLowerCase()
        text.includes(s)
    )
        "cat" ? "meow"
        "dog" ? "woof"
        |       "unknown"
    # speak is "woof"
]]></code></pre>
<p class="detail">One thing different from CoffeeScript is the following code:</p>
<pre class="detail"><code><![CDATA[
    a.b aaa
    .c()
]]></code></pre>
<p class="detail">CoffeeScript compiles it into <code>a.b(aaa).c()</code>, but we strictly follow the rule above to compile it as <code>a.b(aaa.c())</code>. If you want the CoffeeScript effect, you should add parentheses:</p>
<pre class="detail"><code class="fus-part"><![CDATA[
    a.b(aaa)
    .c()
]]></code></pre>
<h2>&lt;&lt; and &gt;&gt;</h2>
<p>Usually, Splitting one line into several lines will add readability. But sometimes things are just the opposite - you will find combining several short lines into one makes it beautiful, particularly when you have many such "several lines". For example:</p>
<pre><code class="fus-part"><![CDATA[
    A: class << aaa: 1 >>
    B: class << bbb: 1 >>
    C: class << ccc: 1 >>
    D: class << ddd: 1 >>
    E: class << eee: 1 >>
]]></code></pre>
<p>It's equivalent to:</p>
<pre><code class="fus-part"><![CDATA[
    A: class
        aaa: 1
    B: class
        bbb: 1
    C: class
        ccc: 1
    D: class
        ddd: 1
    E: class
        eee: 1
]]></code></pre>
<p>This leverages the power of <code>&lt;&lt;</code> and <code>&gt;&gt;</code>. <code>&lt;&lt;</code> means to indent one level, and <code>&gt;&gt;</code> means to unindent one level.</p>
<p><code>&lt;&lt;</code> and <code>&gt;&gt;</code> must be closed in one line. That is, multiple lines can be combined into 1 line, but not into 2 lines.</p>
<p>These 2 symbols, used together with semicolons and commas, can achieve the maximum combination effect. Semicolons combine lines, but object properties, array elements and class properties need to be combined through commas.</p>
<p class="detail">After <code>&gt;&gt;</code> there can be a semicolon or comma, but it's optional. For example:</p>
<pre class="detail"><code class="fus-part"><![CDATA[
    A: class << aaa: x -> << x + 1 >>, bbb: 3 >>
    if aaa << task1() >> else << task2() >>; commonTask()
]]></code></pre>
<p class="detail">Here the semicolon and comma can be omitted.</p>
<h2>Version Line</h2>
<p>The first line of each file must be version line. It's usually in one line so we call it "version line", but it can be in multiple lines. Version line's syntax:</p>
<pre><code><![CDATA[
    [...][fus][...] [-]2.4.0[, (radical | compatible) | (capitalized new | manual new) | (node import | node export | node modules | es modules)]...
]]></code></pre>
<p>Default value is:</p>
<pre><code><![CDATA[
    compatible, capitalized new, es modules
]]></code></pre>
<p>The items separated by comma after the version number can't be duplicated. Examples of version line:</p>
<pre><code><![CDATA[
    2.4.0
    fus 2.4.0
    fus -2.4.0
    2.4.0, node modules
    2.4.0, compatible, capitalized new
    2.4.0, compatible, capitalized new, node import
    2.4.0, radical, manual new
]]></code></pre>
<p>Version number must be written. As long as the number is not greater than the FutureScript version you've installed, the code will be run according to the specification of the file's version. This is because any version you install contains all historical compilers (at least as much as possible). This is exactly the difference between FutureScript and other languages. You can even use different versions for different files in one project.</p>
<p>Another benefit of writing version number is that when you hand your file to somebody else, he will know the version, so that he can better modify it.</p>
<p>This article only describes one version.</p>
<p>When you want to write the version line in multiple lines, a brace must be added. The left (opening) brace must be in the first line. A comma between the version number and the left brace is optional. For example:</p>
<pre><code><![CDATA[
    2.4.0 {
        radical
        node modules
    }
]]></code></pre>
<p>If the file extension isn't <code>.fus</code> or it has no extension, then there must be a <code>fus</code> before the version number. If the file extension is <code>.fus</code>, it's not necessary, but highly recommended, because your text editor can recognize it so that the syntax can be highlighted.</p>
<p>The difference between "radical mode" and "compatible mode" is: radical mode encourages single-argument functions. Did you find the multiple-argument paradigm makes things complicated? If every function can take at most one argument, this argument can be an array, which can also achieve the similar functionality. But this change is too big, so we don't enable it by default. The default mode is compatible mode, in which you can still use all features of multiple-argument functions.</p>
<p>In radical mode, <code>@</code> means JS's <code>arguments[0]</code>. In compatible mode, <code>@</code> means JS's <code>arguments</code>.</p>
<p>All examples in this article are for compatible mode. In radical mode some code needs modification.</p>
<p>FutureScript code can be used by JS. JS code can also be used by FutureScript.</p>
<p id="9cb14d0e-24e4-4cc1-8ef3-f7318845e58b"><code>capitalized new</code> means you don't need to add <code>new</code> when creating an instance of a class. The compiler will automatically add the <code>new</code> to the generated code. It depends on the name of the function or class. If it's capitalized then it will add <code>new</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    animal: Animal() # var animal = new Animal();
]]></code></pre>
<p>This is by default.</p>
<p class="detail">Two forms can be recognized: variable and the normal dot (<code>x.y</code>, it will check <code>y</code>). Things like <code>x."y"</code>或<code>x.y'</code> can't be recognized. For example:</p>
<pre class="detail"><code class="fus-part"><![CDATA[
    aaa."bbb".Ccc() # new can be omitted
    new aaa.bbb."Ccc"() # new can't be omitted
]]></code></pre>
<p><code>manual new</code> is just the traditional way. When creating instance of a class you should add <code>new</code>.</p>
<p><code>node import</code> means all imports are compiled into Node.js imports (i.e. <code>require</code>). <code>node export</code> means all exports are compiled into Node.js exports (i.e. <code>exports</code> and <code>module.exports</code>). <code>node modules</code>means to do both. <code>es modules</code> means to do neither (i.e. comply with ES6). For details, see the "module" section.</p>
<p class="detail">The generated JS code is in strict mode。</p>
<h2>Comment</h2>
<p>Use <code>#</code> (inline) and <code>###</code> (formatted), similar to CoffeeScript. But one thing different is that CoffeeScript's <code>###</code> is compiled for all occurrences, while our <code>###</code> is compiled only when the opening <code>###</code> is immediately below the version line (or there are only whitespaces between them) and the right side of the closing <code>###</code> doesn't have any non-whitespace character, otherwise it will be ignored by the compiler. To comply with JS, the <code>*/</code> in the comment will be compiled into two spaces.</p>
<h1 id="13c8cdd4-8926-4fb8-af19-54ecf57ace68">Function</h1>
<p>There are 3 ways to create a function: arrow <code>-&gt;</code>, diamond <code>&lt;&gt;</code>, dash <code>--</code>. <code>&lt;&gt;</code> and <code>--</code> are shorthand for no parameter. Unlike CoffeeScript, when there's only 1 parameter the parenthesis pair can be omitted.</p>
<pre><code class="fus-part"><![CDATA[
    # both are valid
    a: x -> x + 1
    a: (x) -> x + 1
]]></code></pre>
<p>If there's no parameter, then your must use either of these forms:</p>
<pre><code class="fus-part"><![CDATA[
    a: <> Math.random()
    a: -- Math.random()
    a: () -> Math.random()
]]></code></pre>
<p>Multiple-parameter is allowed, but must be within a parenthesis pair:</p>
<pre><code class="fus-part"><![CDATA[
    a: (x, y) -> x * y
]]></code></pre>
<p>If it's single-parameter, and this parameter is an array, then we can use a form similar to "destructuring assignment":</p>
<pre><code class="fus-part"><![CDATA[
    a: [x, y] -> x * y
]]></code></pre>
<p>With this, radical mode have become truly useful. You can use <code>a[1, 2]</code> to call it (we'll discuss the details later). In fact, if a purpose can be achieved by multiple-parameter, it can also be achieved by the single array parameter, and even more pure. So, in radical mode we discourage the use of multiple parameters (Multiple-parameter is partially supported in radical mode. You can't use <code>@</code> to denote the arguments after the first argument).</p>
<p>Inside <code>&lt;&gt;</code>, we can use <code>@</code>. <code>@</code> supersedes JS's <code>arguments</code> (compatible mode) or <code>arguments[0]</code> (radical mode). It's so handy that in many cases you'd like to take no parameter. For example, we can write:</p>
<pre><code class="fus-part"><![CDATA[
    add: <> @0 + @1
    console.log add(2, 3) # output 5
]]></code></pre>
<p>Parameter can have default value:</p>
<pre><code class="fus-part"><![CDATA[
    a: (x ifvoid: 0, y ifvoid: 0) -> x * y
    b: [x ifvoid: 0, y ifvoid: 0] -> x * y
]]></code></pre>
<p>If it has a default value, then there must be a parenthesis pair (or bracket pair) outside even if there's only 1 parameter.</p>
<p>If it's <code>ifvoid</code> default, then <code>ifvoid</code> can be omitted. So the above example can be simplified to:</p>
<pre><code class="fus-part"><![CDATA[
    a: (x: 0, y: 0) -> x * y
    b: [x: 0, y: 0] -> x * y
]]></code></pre>
<p>Besides <code>ifvoid</code> default, there's also <code>ifnull</code> default. We'll discuss that later.</p>
<p>The following table lists the detailed differences between the 3 function symbols:</p>
<table class="table">
    <tr>
        <th></th>
        <th>Arrow function <code>-&gt;</code></th>
        <th>Diamond function <code>&lt;&gt;</code></th>
        <th>Dash function <code>--</code></th>
    </tr>
    <tr>
        <td>Parameter</td>
        <td>Yes</td>
        <td>No</td>
        <td>No</td>
    </tr>
    <tr>
        <td><code>@</code></td>
        <td>No</td>
        <td>Yes</td>
        <td>No</td>
    </tr>
    <tr>
        <td><code>fun</code></td>
        <td>Yes</td>
        <td>Yes</td>
        <td>No</td>
    </tr>
    <tr>
        <td>Features</td>
        <td>Many</td>
        <td>All. Can simulate the other 2</td>
        <td>Fewer</td>
    </tr>
    <tr>
        <td>Conciseness</td>
        <td>Concise</td>
        <td>Usually very concise, but sometimes not</td>
        <td>Very concise</td>
    </tr>
</table>
<p>For example, for the use of <code>@</code>, the following code:</p>
<pre><code class="fus-part"><![CDATA[
    outer: <>
        inner: x -> @
]]></code></pre>
<p>Here the <code>@</code> doesn't mean <code>inner</code>'s argument, but mean <code>outer</code>'s argument, because the grammar of <code>-&gt;</code> doesn't define <code>@</code>.</p>
<p><code>fun</code> is a keyword, meaning "this function". It's usually written in a recursive function. If the function name is very long, it can reduce your typed characters. It even enables you to use a recursive function without naming it.</p>
<p>Similarly, because the grammar of <code>--</code> doesn't define <code>fun</code>, the <code>fun</code> inside <code>--</code> means the outer <code>-&gt;</code> or <code>&lt;&gt;</code> function.</p>
<p>Inner parameter can't have the same name as any of outer parameters. This is stricter than CoffeeScript and JS. It might be less strict in later versions.</p>
<p>We have known that member access all uses <code>.</code>. Another benefit of it is that in function call you can omit parentheses and use brackets directly.</p>
<p>Function call has 4 notations: space, parenthesis <code>()</code>, bracket <code>[]</code>, and brace <code>{}</code>.</p>
<pre><code class="fus-part"><![CDATA[
    a(2)
    a 2 # equivalent to above
    a[3, 4, 5] # a([3, 4, 5])
    a{prop: true} # a({prop: true})
    a(3, 4, 5)
]]></code></pre>
<p>In multiple-argument function call a parenthesis pair must be added. This is different from CoffeeScript. Space call is only applicable in single-argument function call. And of course we all know that if it takes no argument then <code>()</code> must be added.</p>
<p>In CoffeeScript, if the passed argument is itself a function which takes no parameters, then it could be written as:</p>
<pre><code class="coffee"><![CDATA[
    abc -> Math.random()
]]></code></pre>
<p>Because CoffeeScript understands it as:</p>
<pre><code class="coffee"><![CDATA[
    abc (-> Math.random())
]]></code></pre>
<p>But in FutureScript you couldn't write so, because the compiler will treat it as a function with parameter <code>abc</code>. You must write either of these:</p>
<pre><code class="fus-part"><![CDATA[
    # pass a function as argument to abc
    abc <> Math.random()
    abc -- Math.random()
    abc () -> Math.random()
]]></code></pre>
<p>We can also use <code>'</code> to achieve the "splat" effect:</p>
<pre><code class="fus-part"><![CDATA[
    awardMedals' contenders # awardMedals.apply(null, contenders)
]]></code></pre>
<p>Equivalent to ES6's</p>
<pre><code class="js"><![CDATA[
    awardMedals(...contenders)
]]></code></pre>
<p>The apostrophe <code>'</code> is called variant. <code>'</code> is a unique symbol in FutureScript. Not limited to this form. We will discuss it later.</p>
<p>You can use the spread symbol <code>...</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    a: (x, y...) -> y.length
    a(0, 0, 0) # returns 2
]]></code></pre>
<p>Spread symbol <code>...</code> can also be in function call. For example:</p>
<pre><code class="fus-part"><![CDATA[
    a: [2, 3]
    b(1, a...) # b(1, 2, 3)
]]></code></pre>
<p>For now, the limitation for the spread symbol <code>...</code> is: It must be the last argument / parameter, and can't be in an array. Future version may free this limitation.</p>
<p>Note that these 2 functions are different:</p>
<pre><code class="fus-part"><![CDATA[
    a{prop: true}.b # a({prop: true}).b
    a {prop: true}.b # a({prop: true}.b)
]]></code></pre>
<p>Every function has a return value - the value of the function block, so we don't need to use <code>return</code>. What does the value of the function block mean? The accurate definition is described before. Now I give an informal definition: It's just the last statement's value in that function. If the last statement isn't an expression, then it's <code>void</code>. This rule is very important - it's the core of the functional programming. For example:</p>
<pre><code class="fus-part"><![CDATA[
    calc: (x, y) ->
        a: x * x
        b: y * y
        a + b
    calc(2, 3) # returns 13
]]></code></pre>
<p>This rule applies to not only the function block, but blocks inside <code>if...then...else...</code>, and all other blocks (except the root block).</p>
<p>Unlike CoffeeScript, we don't have fat arrow <code>=&gt;</code>, because I think JavaScript's changeable meaning of <code>this</code> isn't a good design. It should always point to the current object.</p>
<p class="detail">The mapping between our function and CoffeeScript's function is as follows:</p>
<ul class="detail">
    <li>Class method and constructor (including nested class's method and constructor): CoffeeScript thin arrow</li>
    <li>Inside class method and constructor (excluding nested class's method or constructor, but including those inside nested class's method and constructor: CoffeeScript fat arrow</li>
    <li>The rest: CoffeeScript thin arrow</li>
</ul>
<h1>Assignment</h1>
<p>Use <code>:</code> and <code>as</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    a: "hello world" # var a = "hello world";
    3 as b # var b = 3;
]]></code></pre>
<p>Note that <code>:</code> doesn't form an expression, but <code>as</code> forms an expression. For example:</p>
<pre><code class="fus-part"><![CDATA[
    abc: <>
        a: 1
]]></code></pre>
<p>Run <code>abc()</code> and the return value is <code>void</code> not <code>1</code>. But</p>
<pre><code class="fus-part"><![CDATA[
    abc: <>
        1 as a
]]></code></pre>
<p>Run <code>abc()</code> and the return value is <code>1</code>.</p>
<p>Variables don't need, and shouldn't be declared, because our variables are automatically declared. This mechanism is like CoffeeScript, but with notable difference mainly in dealing with the inner and outer level:</p>
<ul>
    <li>CoffeeScript: If it doesn't exist in the <b>preceding outer level</b>, then it will be compiled to "declare and assign". If exist, then it will be compiled to "assign only".</li>
    <li>FutureScript: If it doesn't exist in the <b>outer level</b>, then it will be compiled to "declare and assign". If exist, then it will be compiled to "assign only".</li>
</ul>
<p>These two codes are equivalent. Both are compiled to a single variable:</p>
<p>CoffeeScript:</p>
<pre><code class="coffee"><![CDATA[
    a = 3
    ->
        a = 5
]]></code></pre>
<p>FutureScript:</p>
<pre><code class="fus-part"><![CDATA[
    a: 3
    --
        a: 5
]]></code></pre>
<p>But these two are different:</p>
<p>CoffeeScript:</p>
<pre><code class="coffee"><![CDATA[
    ->
        a = 5
    a = 3
]]></code></pre>
<p>CoffeeScript compiles it to two variables with the same name <code>a</code>. But in FutureScript:</p>
<pre><code class="fus-part"><![CDATA[
    --
        a: 5
    a: 3
]]></code></pre>
<p>will be compiled to a single variable <code>a</code>.</p>
<p>Auto-declaration is inspired by CoffeeScript. I think it's one of the best features in CoffeeScript. Maybe many people don't agree, feeling it's a bad feature because it inhibits declaring a same-name variable in inner level. But this is not the truth. In a large project, it's reasonable for different developers to manage different files, for modules are isolated; but it isn't reasonable for different developers to manage the inner and outer level of a file respectively, for it will cause chaos. Now that a file's inner and outer level should be managed as a whole, when you name an inner-level variable, it's not difficult to pay attention to the outer level, so there's really no need to support the same-name variable in inner level. We even do it more thoroughly than CoffeeScript.</p>
<p><code>:</code> supports array destructuring assignment (without nested). For example:</p>
<pre><code class="fus-part"><![CDATA[
    [a, b]: [b, a] # swap a and b
]]></code></pre>
<p>The effect or a colon is just to let the left side have the value of the right side, be it in object or in assignment.</p>
<p><code>:</code> supports assigning a value to multiple identifiers. For example:</p>
<pre><code class="fus-part"><![CDATA[
    a, b: 1 # both a and b are 1
]]></code></pre>
<p>If a name isn't a FutureScript keyword, it can be a variable name. Even JS keywords such as <code>function</code> can be variable names. But JS keywords can't be global variable names.</p>
<h1>Module</h1>
<p>If you want to continue using Node's <code>require</code>, <code>exports</code> and <code>module.exports</code>, you can simply skip this section. In FutureScript you can still use them as usual.</p>
<p>We know that Node has its own module system, but the problem is that this system doesn't belong to ES6. ES6 defines a native JS module syntax. Because FutureScript is based on JS, our native module syntax is based on ES6.</p>
<p>One file is to one module. Syntaxes related to module are <code>import</code>, <code>export</code> and <code>'export</code>.</p>
<h2 id="c88a5a59-72cf-4778-b414-a5da92a89ec4">Import</h2>
<pre><code class="fus-part"><![CDATA[
    main: import "lib"
]]></code></pre>
<p>or</p>
<pre><code class="fus-part"><![CDATA[
    import "lib" as main
]]></code></pre>
<p>Both mean to import ES6's default export, equivalent to JS's:</p>
<pre><code class="js"><![CDATA[
    import main from "lib";
]]></code></pre>
<p>If the version line uses the default value, it will be compiled to the above JS. But the wonderful thing is: if the version line has <code>node import</code> or <code>node modules</code>, the same code will be compiled into:</p>
<pre><code class="js"><![CDATA[
    var main = require("lib");
]]></code></pre>
<p>Without modifying your code, you can control whether to use Node module system or ES6 module system for all <code>import</code> in this file. So now <code>import</code> can replace <code>require</code>.</p>
<p>In fact, because currently Node.js and browsers only provide partial ES6 support, you may have to use Babel to convert it to ES5, and Babel will automatically convert your <code>import</code> to use the Node module system, so even if you don't specify it in the version line, I think it doesn't matter (but there may be slight differences).</p>
<p>To import all named exports:</p>
<pre><code class="fus-part"><![CDATA[
    lib: import "lib" all
]]></code></pre>
<p>Or</p>
<pre><code class="fus-part"><![CDATA[
    import "lib" all as lib
]]></code></pre>
<p>Equivalent to JS's:</p>
<pre><code class="js"><![CDATA[
    import * as lib from "lib";
]]></code></pre>
<p>To import specified named exports:</p>
<pre><code class="fus-part"><![CDATA[
    {fun1, fun2 as f2}: import "lib"
]]></code></pre>
<p>Or</p>
<pre><code class="fus-part"><![CDATA[
    import "lib" as {fun1, fun2 as f2}
]]></code></pre>
<p>Equivalent to JS's:</p>
<pre><code class="js"><![CDATA[
    import {fun1, fun2 as f2} from "lib";
]]></code></pre>
<p>Importing both default export and named exports is not supported. If you have this requirement please split them into two statements. I think it's not good for a module to have both default export and named exports.</p>
<p class="detail">Note, that some examples above use the feature that <code>all</code> can be omitted. The complete form is:</p>
<pre class="detail"><code class="fus-part"><![CDATA[
    {fun1, fun2 as f2}: import "lib" all
    import "lib" all as {fun1, fun2 as f2}
]]></code></pre>
<p class="detail"><code>import</code> can only be followed by an inline normal string. The string can't have interpolations (but can have escapes). <code>import</code> can't have both colon and <code>as</code>. These are correct <code>import</code> statements:</p>
<pre class="detail"><code class="fus-part"><![CDATA[
    import "./abc" as abc
    abc: import "./abc"
    abc: import "abc" all
    import "abc"
    import "\u0041"
]]></code></pre>
<p class="detail">These are illegal <code>import</code> statements:</p>
<pre class="detail"><code><![CDATA[
    import("abc")
    import "./a" + "bc" # But this is legal as import expression
    import "./\(filename)"
    import v"abc"
    aaa: import "bbb" as ccc
]]></code></pre>
<p>An <code>import</code> assignment is not a normal assignment. It is "binding", like in ES6. So it's limited to variables. It can't be assigned to object properties. There can't be <code>ifvoid</code>, <code>ifnull</code> or <code>'</code> before the colon.</p>
<p id="28715698-580a-4a4d-b70c-91126bffa74b">When we use Node we often come into this situation：Each file has a large number of imports, most of which are duplicated, but can't be omitted. Of course you can create a new module and put everything into it, then export, so each module only needs to import this new module. For example:</p>
<pre><code class="fus-part"><![CDATA[
    aaa: import "aaa"
    bbb: import "bbb"
    ccc: import "ccc"
    aaa()
    bbb()
    ccc()
]]></code></pre>
<p>You create a <code>all.fus</code> file and put the 3 <code>import</code> into it and write the following in the original file:</p>
<pre><code class="fus-part"><![CDATA[
    all: import "./all"
    all.aaa()
    all.bbb()
    all.ccc()
]]></code></pre>
<p>But the problem is: When calling, <code>all.</code> must be added. So it seems not much shorter than before.</p>
<p>FutureScript has a unique "batch import" feature (even ES6 doesn't have). If there's <code>all</code> but no colon or <code>as</code>, then it will be compiled to batch import. It will import all named exports (except the default export) and let them all be variable names. So, we can write:</p>
<pre><code class="fus-part"><![CDATA[
    import "./all" all
    aaa()
    bbb()
    ccc()
]]></code></pre>
<p>This feature has an important property: When compiling, it needs to generate variable names by reading the imported module. To ensure the path's parsing mechanism is the same as runtime, we made the parser as simple as possible. So it only supports paths starting with <code>"./"</code>, <code>"../"</code> or <code>"/"</code>. So this is a limitation: it's only suitable for importing another module in the current project, not suitable for importing directly from another project by using the module name. So if you want to import between projects, you need to have a "manifest" module as the "middle" in the current project.</p>
<p>"Batch import" doesn't introduce global variables, so it's not evil. These variables are invisible in other modules, unless other modules batch-import them too.</p>
<p>If A batch imports B, and if some B's named export (imported as A's variable) happen to be a keyword of A's FutureScript version, then this variable will be inaccessible, but it won't cause error.</p>
<p>A normally imported module can be a Fus or JS file, but a batch imported module must be a Fus file (any version number is allowed).</p>
<p>In the above we introduced <code>import</code> statement. <code>import</code> can also act as expression. The syntax is: <code>import "module-name"</code>. It can't be followed by <code>as</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    import "abc"
    import "abc" + 1
    a: import "abc" + 1
]]></code></pre>
<p>So the syntax of <code>import</code> expression gives you more freedom, but it can only import default exports. Also, if used together with assignment, then it's a normal assignment, not a binding.</p>
<h2 id="e652b57f-7914-464d-b58d-d34eef33ab97">Export</h2>
<p>When export, we can use 4 syntaxes: <code>export</code>, <code>'export</code>, <code>export as</code>, <code>export ... as</code>. These are all correct:</p>
<pre><code class="fus-part"><![CDATA[
    multiply'export: <> @0 * @1
    mp: (<> @0 * @1) export as multiply
    mp: (<> @0 * @1) as multiply'export
    abc export as def
    export abc as def
    export abc
    export: abc # note that this is different from above
    export: <> @0 * @1
]]></code></pre>
<p>These are illegal:</p>
<pre><code><![CDATA[
    abc export def
    export {abc}
    export multiply: <> @0 * @1
    obj.multiply'export: <> @0 * @1
]]></code></pre>
<p>Note that <code>abc export as def</code> and <code>export abc as def</code> behave similarly, but with two differences. One is obvious: the former is an expression statement while the latter is a command statement. The other is subtle: The former <code>abc</code> is treated as an expression, while the latter <code>abc</code> is treated as a variable. This makes it so that: The former is not a binding, but the latter is a binding (can have the benefit of ES6 module's variable binding).</p>
<p>If a statement starts with <code>export:</code>, it means ES6's default export. For example:</p>
<pre><code class="fus-part"><![CDATA[
    export: abc
]]></code></pre>
<p>If the version line has <code>node export</code> or <code>node modules</code>, this statement will be compiled into:</p>
<pre><code class="js"><![CDATA[
    module.exports = abc;
]]></code></pre>
<p class="detail">This kind of statement can appear only once. If it appears, then there can't be any other exports, otherwise a compiler error will be raised. This is because (as mentioned before) it's not good to have both default export and named exports in one module. Although for compatibility FutureScript supports importing a JS module of this architecture, for Fus module we can dismiss this architecture.</p>
<p class="detail">Default export can be in this form:</p>
<pre class="detail"><code class="fus-part"><![CDATA[
    export abc as default
]]></code></pre>
<p class="detail">So default export is actually a special named export (for details see ES6 articles). If you name it <code>default</code> then it's default export.</p>
<p class="detail">So these two:</p>
<pre class="detail"><code class="fus-part"><![CDATA[
    export abc as default
    export: abc
]]></code></pre>
<p class="detail">They behave similarly. The only difference is: The former <code>abc</code> is treated as a variable, so it's a binding. The latter <code>abc</code> is treated as an expression, so it's not a binding. (This is the same as ES6's rule. ES6's <code>export {... as default}</code> and <code>export default ...</code> also has such difference.)</p>
<p>Imports and exports must be in the outermost level, because it's based on ES6. Our imports are static, not dynamic, so it's stricter than Node. But I know in some cases you may need to dynamic import, you can use <code>require</code> instead of the native module syntax.</p>
<h1>Data</h1>
<h2>String and RegExp</h2>
<p>Inline string:</p>
<pre><code class="fus-part"><![CDATA[
    str: "Welcome to FutureScript!"
]]></code></pre>
<p>Formatted string:</p>
<pre><code class="fus-part"><![CDATA[
    htmlStr: "
        <p>
            Welcome to "FutureScript"!
        </p>
    "
]]></code></pre>
<p>The above string is equal to CoffeeScript's</p>
<pre><code class="coffee"><![CDATA[
    htmlStr = """
        <p>
            Welcome to "FutureScript"!
        </p>
    """
]]></code></pre>
<p>You may wonder why we can use only 1 quotation mark to wrap a text block (the text itself has quotation marks). The secret is that we require every indent in the string to be greater than the indent of the quotation mark, and require that the indent of the opening quotation mark be the same as that of the closing quotation mark. So no matter how many quotation marks there are inside the string, they won't affect the compiler.</p>
<p>The opening quotation mark of a formatted string must be followed immediately by a newline (the 2 newlines for starting and ending doesn't count towards the string characters). In the line of the closing quotation mark, before the quotation mark there should only be whitespaces. Within a line inside the string, the left part of the indent doesn't count towards the string characters until an indent whitespace exceeds the "minimum indent in the string". Note: Here "minimum indent" doesn't include empty lines.</p>
<p>The inside of a formatted string can't be all whitespaces (except those in escape form). For example, these are all illegal:</p>
<pre><code><![CDATA[
    str: "
    "

    str: "

    "
]]></code></pre>
<p>Although this also represents a space, it's valid:</p>
<pre><code class="fus-part"><![CDATA[
    str: "
        \x20
    "
]]></code></pre>
<p class="detail">How does the compiler determine if it's inline or formatted? It checks the character immediately after the opening quotation mark. If it's newline, then formatted. If otherwise then inline.</p>
<p>We don't use apostrophe to represent strings, because I feel when you want to use it, if the string is very long, you can use formatted <code>"</code>; If the string is very short, such as <code>'"'</code>, this just add very little readability. I'd rather use<code>"\""</code>. Neither of these has an obvious advantage over the double quotation mark. So, better not spend the precious symbol resource on this. Also, double quotation mark is consistent with JSON.</p>
<p id="1178787f-e307-4df2-9149-f0197bb762a3">Like CoffeeScript, we support string interpolation, but we use <code>\(...)</code>.</p>
<pre><code class="fus-part"><![CDATA[
    str: "Today is \(year)-\(month)-\(day)."
]]></code></pre>
<p>An interpolation can't occupy multiple lines. For now we don't support interpolation with quotation marks in it (i.e. nested strings). In fact, even if we support it, it will look very complicated and thus not beautiful. You may well assign it to a variable and interpolate the variable.</p>
<p>In the above we introduced the normal string. Besides normal string there are special string and string extension. What's a string extension? Regular expression is a typical example.</p>
<p>To represent a regular expression, we use <code>r"..."</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    str.search(r"^\d{3}-\d{3}-\d{4}$")
]]></code></pre>
<p>The inline regular expression suppresses most features of <code>\</code> except these 2：<code>\"</code> and the line-end connectable <code>\</code>. Note, that in JS <code>"</code> and <code>#</code> can be written directly in a regular expression, but here we must use <code>\"</code> and <code>\#</code>, for these 2 characters have special meanings.</p>
<p>Regular expression can have interpolations. It interpolates strings:</p>
<pre><code class="fus-part"><![CDATA[
    first: "hello"
    second: "world"
    r"#(first)-#(second)"
]]></code></pre>
<p>Equivalent to CoffeeScript, if the regular expression interpolation is a normal string, it will be verbose if you want to express the <code>\</code> character, so it's recommended to use it only to insert non-symbol characters.</p>
<p>Representing flagged regular expression is also possible:</p>
<pre><code class="fus-part"><![CDATA[
    r"\d{3}-\d{3}-\d{4}"gim
]]></code></pre>
<p>An example of formatted regular expression:</p>
<pre><code class="fus-part"><![CDATA[
    str.search(r"
        ^
        \d{3} # first
        -
        \d{3} # second
        -
        \d{4} # third
        $
    ")
]]></code></pre>
<p>The difference of a formatted regular expression is: Whitespace and newline are meaningless. Support comments. Simpler to represent double quotes. There must be at least one space before the comment character <code>#</code>. This is different from normal comments.</p>
<p>Verbatim string is inspired by C#. A verbatim string is represented by <code>v"..."</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    path: v"C:\Windows\System"
]]></code></pre>
<p>A verbatim string suppresses all the features of <code>\</code>, so you can't connect using <code>\</code> in line end. In inline verbatim strings you can't represent double quotation marks.</p>
<p>So in summary, if the opening <code>"</code> is preceded immediately by a letter, then it means a string or string extension.</p>
<p class="detail">In essence, the content enclosed by quotation marks in a regular expression is a string. This is different from JS and CoffeeScript. Even the comment in a formatted regular expression belongs to a string in essence (but just got removed during conversion). Note, that the conversion is at runtime not compile time. Because it's possible to have interpolations, we can't convert it while compiling.</p>
<p>There's another difference from CoffeeScript. In CoffeeScript:</p>
<pre><code class="coffee"><![CDATA[
    mobyDick = "Call me Ishmael. Some years ago --
    never mind how long precisely -- having little
    or no money in my purse, and nothing particular
    to interest me on shore, I thought I would sail
    about a little and see the watery part of the
    world..."
]]></code></pre>
<p>This will be compiled to "join multiple lines by a space". But we do not support. One reason is that it's not compatible to our grammar. Another reason is that this only applies to western languages. For example, if it's Chinese then adding a space is wrong. So I think it's better to use<code>\</code> to join. If it's English, then manually add a space before it.</p>
<p>The following table lists the escape rule for all kinds (the escape during conversion is not included, for example the <code>\</code> in regular expression itself):</p>
<table class="table">
    <tr>
        <th></th>
        <th>Inline "</th>
        <th>Formatted "</th>
        <th>Inline v"</th>
        <th>Formatted v"</th>
        <th>Inline r"</th>
        <th>Formatted r"</th>
        <th>Inline js"</th>
        <th>Formatted js"</th>
    </tr>
    <tr>
        <td>\ Normal Escape</td>
        <td>Yes</td>
        <td>Yes</td>
        <td>No</td>
        <td>No</td>
        <td>No</td>
        <td>No</td>
        <td>No</td>
        <td>No</td>
    </tr>
    <tr>
        <td>\\</td>
        <td>Yes</td>
        <td>Yes</td>
        <td>No</td>
        <td>No</td>
        <td>Yes</td>
        <td>No</td>
        <td>No</td>
        <td>No</td>
    </tr>
    <tr>
        <td>\"</td>
        <td>Yes</td>
        <td>Yes but not required</td>
        <td>No</td>
        <td>Not required and no</td>
        <td>Yes</td>
        <td>Not required and no</td>
        <td>No</td>
        <td>Not required and no</td>
    </tr>
    <tr>
        <td>\ Connect</td>
        <td>Yes</td>
        <td>Yes</td>
        <td>No</td>
        <td>No</td>
        <td>Yes</td>
        <td>Yes</td>
        <td>No</td>
        <td>No</td>
    </tr>
    <tr>
        <td>Interpolation</td>
        <td>\(...)</td>
        <td>\(...)</td>
        <td>No</td>
        <td>No</td>
        <td>#(...)</td>
        <td>#(...)</td>
        <td>No</td>
        <td>No</td>
    </tr>
</table>
<h2>Array</h2>
<p>The bracket pair <code>[...]</code> is to represent an array literal or an array-like thing (in destructuring assignment). No other uses.</p>
<p>The dot <code>.</code> is to access an object property. Because an array is also an object, JS's <code>arr[3]</code> is superseded by <code>arr.3</code>, which is more consistent. In fact an array is an object whose property name is the index (converted to string). If you don't believe you can test by typing <code>Object.keys(arr)</code>. JS is different than other languages in this part, but it's not a bad part, because the concept is consistent.</p>
<p>Of course, when used together with fractions it may look unsuitable. In this case you can add a parenthesis pair. Compare the following:</p>
<pre><code class="fus-part"><![CDATA[
    x.1 + x.2 + 3.5
    x.(1) + x.(2) + 3.5 # the same as above but looks better
    x1.1 + x1.2 + 2.4
    x1.(1) + x1.(2) + 2.4 # the same as above but looks much better
]]></code></pre>
<p><code>a.(b)</code> is equivalent to JS's <code>a[b]</code>.</p>
<p>The notation of array literal is the same as CoffeeScript.</p>
<h2>Object</h2>
<p>The notation of object literal is similar to CoffeeScript, but it must be enclosed with a brace pair <code>{...}</code>, which can't be omitted.</p>
<p>In object property access, if the left side of a dot <code>.</code> is a number, then the number must be enclosed by parentheses, for example <code>(1).toString()</code>. This restriction is to avoid ambiguity, such as <code>1.3</code>. You may argue that there's no ambiguity because <code>1</code> is unlikely to be an array, then how about <code>1.3.a</code>? It feels weird, less intuitive than <code>(1.3).a</code>. So in this point we are stricter than JS (JS doesn't allow <code>1.a</code>, but allow <code>1.3.a</code>).</p>
<p id="d32afece-1962-414d-9720-ccb039b55a72">FutureScript provides the unique "flexible object notation". It supports two types of flexibilities. In type-1, colons and <code>true</code> can be omitted. For example:</p>
<pre><code class="fus-part"><![CDATA[
    options: {
        port: 443
        rejectsUnauthorized
    }
]]></code></pre>
<p>Equivalent to JS's:</p>
<pre><code class="js"><![CDATA[
    options = {
        port: 443,
        rejectsUnauthorized: true
    };
]]></code></pre>
<p id="4f86f72f-4e5f-4f17-89a1-fb5e48fd2eca">In type-2, colons and commas are omitted. For example:</p>
<pre><code class="fus-part"><![CDATA[
    loop{1 to 5 for i ->
        console.log(i * i)
    }
]]></code></pre>
<p>Equivalent to JS's:</p>
<pre><code class="js"><![CDATA[
    loop({
        "": 1,
        to: 5,
        for: function(i) {
            console.log(i * i);
        }
    });
]]></code></pre>
<p id="0a58dc19-117d-444a-93a3-f6ddef662118">Another example of flexible object notation is enum:</p>
<pre><code class="fus-part"><![CDATA[
    Color: enum{red, green, blue}
    # Color.red is 0, Color.green is 1, Color.blue is 2
]]></code></pre>
<p>Because it's equivalent to JS's:</p>
<pre><code class="js"><![CDATA[
    Color = enum({
        red: true,
        green: true,
        blue: true
    });
]]></code></pre>
<p>The above 2 examples use the <code>loop</code> function (type-2) and <code>enum</code> function (type-1) in fus-ext package, respectively. The flexible object notation is so expressive and powerful that you are close to have the ability to customize grammars. We will never need the grammar of native loop or enum. Simply call a function and it will be as concise or even conciser than a language with native grammars.</p>
<p>Note, that you can't apply both type-1 and type-2 to an object. Additionally, in type-2 each line must have at least two items (key or value counts as one item respectively). So <code>{a b}</code> is of type-2 (equivalent to <code>{a: b}</code>), while <code>{a}</code> is of type-1 (equivalent to <code>{a: true}</code>).</p>
<p>In type-2, if the number of items is odd, then the first item is parsed as a value rather than a key. Its key is an empty string. See <code>loop</code> example.</p>
<p>In type-2, you can't use space to call a function. You should use parenthesis pair.</p>
<p>Regardless of the type, if a key isn't followed by a colon, then the key itself can't be written as an expression. For example this is illegal:</p>
<pre><code><![CDATA[
    Color: enum{"red", "green", "blue"}
]]></code></pre>
<p>In type-2, a keyword acts as a keyword only if the item is a value. That is, the following code:</p>
<pre><code class="fus-part"><![CDATA[
    {true or false}
]]></code></pre>
<p>Will be compiled to:</p>
<pre><code class="js"><![CDATA[
    {
        "": true,
        or: false
    }
]]></code></pre>
<p>You can write:</p>
<pre><code class="fus-part"><![CDATA[
    {set a + b}
]]></code></pre>
<p>But if you want to modify the operator to <code>or</code>, then you should add a parenthesis pair:</p>
<pre><code class="fus-part"><![CDATA[
    {set (a or b)}
]]></code></pre>
<p class="detail">In type-2, key name can't be <code>not</code> or <code>as</code>.</p>
<p>Finally, please note that since the examples in this section contain external functions, these examples are likely to be outdated.</p>
<h2>Literal</h2>
<p>There are the following kinds of literal:</p>
<ul>
    <li>Number literal</li>
    <li>Boolean literal</li>
    <li>String literal</li>
    <li>String extension literal</li>
    <li><code>null</code> literal</li>
    <li><code>void</code> literal</li>
    <li>Object literal</li>
    <li>Array literal</li>
    <li>Function literal</li>
    <li>Class literal</li>
</ul>
<p>A literal is an expression. Its difference from a normal expression is:</p>
<ul>
    <li>A literal is a constant.</li>
    <li>A literal by itself isn't an identifier (but can contain identifiers).</li>
    <li>A literal belongs to some certain type (note that "type" is wider than "class" in range).</li>
    <li>A literal is usually the source of creating a value of this certain type.</li>
    <li>A literal has a specific notation.</li>
</ul>
<h2>Context</h2>
<p>We have 6 keywords or symbols to denote the contexts, as follows:</p>
<ul>
    <li>Current object: <code>me</code></li>
    <li>Current object's class: <code>Me</code></li>
    <li>Parent object's member: <code>super</code></li>
    <li>Current function in the closure: <code>fun</code></li>
    <li>Current argument: <code>@</code></li>
    <li>The left side of the colon in assignment: <code>self</code></li>
</ul>
<p>The dot immediately after <code>@</code> can be omitted, except that the dot is followed by <code>(</code> or string or string extension such as <code>"</code>, <code>v"</code> and <code>r"</code>.</p>
<p id="07f8b8dd-4758-4796-96bf-7e5c18b0adf8"><code>self</code> can represent complex self-assignment. For example, when you want to self-add something to the left side rather than the right side:</p>
<pre><code class="fus-part"><![CDATA[
    longString: "foo"
    longString: "prefix-" + self
    # longString will be "prefix-foo"
]]></code></pre>
<h1>Control Flow</h1>
<h2>Logical Operation</h2>
<ul style="font-family: monospace;">
    <li>=</li>
    <li>/= (not =, not=, ≠)</li>
    <li>&lt;</li>
    <li>&gt;</li>
    <li>&lt;= (≤)</li>
    <li>&gt;= (≥)</li>
    <li>and</li>
    <li>or</li>
    <li>not</li>
</ul>
<p>The equals sign <code>=</code> is just to determine equality. No longer need to distinguish between <code>=</code>, <code>==</code> and <code>===</code>.</p>
<p><code>/=</code> or <code>≠</code> means inequality. It can also be written as <code>not =</code>, where the space can be omitted. The highlight here is <code>≠</code>. If you use Mac, you can directly input <code>≠</code> by holding "Alt" key and pressing "=". Mac natively supports inputting inequality signs. If you use Windows, you can define shortcut keys in your editor, so actually everyone can input <code>≠</code> easily. This greatly improves readability.</p>
<p>Why don't we use <code>!=</code>? Because <code>!</code> isn't used by FutureScript so far, I really don't want a precious symbol to be only usable with <code>=</code>. <code>/=</code> also looks more like <code>≠</code> than <code>!=</code>.</p>
<p>Like CoffeeScript, we support chained comparison (for now only support 3 operands):</p>
<pre><code><![CDATA[
    if 200 ≤ statusCode < 300
        console.log "success"
]]></code></pre>
<p>But our limitation is more than CoffeeScript. You can only compare in the same direction. Such is not supported:</p>
<pre><code><![CDATA[
    if a < b > c
        console.log "success"
]]></code></pre>
<p>For logical operation, the biggest difference in FutureScript is the precedence of <code>not</code>. <code>not</code> is lowered, only higher than <code>and</code> and <code>or</code>. This means we can omit many parentheses. You must have complained in JS you have to write:</p>
<pre><code class="js"><![CDATA[
    if !(abc instanceof Abc) doTask();
]]></code></pre>
<p>But now we can:</p>
<pre><code><![CDATA[
    if not abc instanceof Abc
        doTask()
]]></code></pre>
<p>But in fact this example is illegal, because we don't have <code>instanceof</code>. We use <code>is</code>. You can write <code>not abc is Abc</code> but it's a bit ugly (so we support <code>abc isnt Abc</code>). So are there any beautiful examples? Yes, in this example you can also omit parentheses:</p>
<pre><code class="fus-part"><![CDATA[
    if not 200 ≤ statusCode < 300
        console.log "failure"
]]></code></pre>
<p>Back to the inequality sign. You can also use <code>not ... =</code>. These 5 forms behaves the same:</p>
<pre><code class="fus-part"><![CDATA[
    if statusCode ≠ 200 throw
    if statusCode /= 200 throw
    if statusCode not= 200 throw
    if statusCode not = 200 throw
    if not statusCode = 200 throw
]]></code></pre>
<p class="detail">But <code>not ... =</code> generates different code than the other 3, though the behavior is the same.</p>
<h2 id="489b552b-f32e-42e7-84ee-c43e1100c4d3">Condition</h2>
<p>Use<code>if</code>, <code>?</code>, <code>then</code>, <code>else</code>, <code>|</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    b:
        if a = 3
            "three"
        else
            "other"
]]></code></pre>
<p id="45cf5b2b-c445-4018-b491-d3c46f61aa50">Or</p>
<pre><code class="fus-part"><![CDATA[
    b:
        a = 3 ?
            "three"
        else
            "other"
]]></code></pre>
Can be combined into one line:
<pre><code class="fus-part"><![CDATA[
    b: if a = 3 then "three" else "other"
]]></code></pre>
<p>Or</p>
<pre><code class="fus-part"><![CDATA[
    b: a = 3 ? "three" else "other"
]]></code></pre>
<p>Or even</p>
<pre><code class="fus-part"><![CDATA[
    b: a = 3 ? "three" | "other"
]]></code></pre>
<p><code>?</code> is equivalent to <code>then</code>, and <code>|</code> is equivalent to <code>else</code>. This rule is not limited to <code>if</code>, but rather in all the language. Any rule mentioned hereinafter is applicable to its equivalent. For example, the rule of <code>then</code> also applies to <code>?</code>.</p>
<p>When the condition is prefixed, <code>if</code> can be omitted, and <code>then</code> can be omitted if <code>then</code> block isn't an inline block. When <code>if</code> is omitted take note of the precedence problem it may cause. For example:</p>
<pre><code class="fus-part"><![CDATA[
    a if b > 100 then 100 else b
]]></code></pre>
<p>Here if the <code>if</code> is omitted the meaning will be changed, unless a parenthesis pair is added.</p>
<p>When <code>then</code> is followed by a keyword of command statement, <code>then</code> can also be omitted (this also applies to pattern matching, which we will discuss later). For example:</p>
<pre><code class="fus-part"><![CDATA[
    if a > 100 throw new Error()
]]></code></pre>
<p>If there's no <code>else</code> block, then if the condition matches <code>else</code>, the whole <code>if</code> expression's value will be <code>void</code>.</p>
<p>But note that however omitted, you can't omit both <code>if</code> and <code>then</code> in the prefixed-condition form.</p>
<p>Condition can also be postfixed. For example:</p>
<pre><code class="fus-part"><![CDATA[
    console.log("a is true!") if a # if (a) {console.log("a is true!");}
    mood: "happy" if singing # if (singing) {mood = "happy";}
]]></code></pre>
<p class="detail">When condition is postfixed, <code>if</code> can't be omitted. One statement can only have one postfixed <code>if</code>. It must be in the outermost level of a statement (can't be enclosed with parentheses). Also, the block before <code>if</code> can't be a normal block. It can only be an inline block. Because postfixed <code>if</code> must be in the outermost level, so if a colon assignment is before it, then the code between the colon and <code>if</code> should belong to the colon not <code>if</code>.</p>
<p>Another thing different from CoffeeScript is when come across semicolons:</p>
<pre><code class="coffee"><![CDATA[
    if x > 100 then aaa(); bbb()
]]></code></pre>
<p>CoffeeScript treats <code>aaa(); bbb()</code> as child statements. But this rule looks inconsistent with other rules. Also we have unique symbols for this so it can be written as:</p>
<pre><code class="fus-part"><![CDATA[
    if x > 100 << aaa(); bbb() >>
]]></code></pre>
<p>So CoffeeScript's "semicolon rule" is cancelled in our language. In FutureScript, the left and right side of semicolon can pass through any obstacles, provided there's no grammar error.</p>
<h2 id="f79a8657-a1a6-42d6-a2ff-fbb5782ae2c5">Pattern Matching</h2>
<p><code>match</code> can be regarded as an enhanced version of <code>switch</code>, called pattern matching. For example:</p>
<pre><code class="fus-part"><![CDATA[
    day: 3
    text: match day
        1 ? "Mon"
        2 ? "Tue"
        3 ? "Wed"
        4 ? "Thu"
        5 ? "Fri"
        6 ? "Sat"
        |   "Sun"
    # text will be "Wed"
]]></code></pre>
<p>Above is the simplest pattern matching, where <code>day</code> is called the input, and 1, 2, 3... is called patterns.</p>
<p>The "comparison" is by default using <code>=</code> to directly compare the input with a pattern. <code>match</code> can also be followed by not the input, but a comparison function. For example:</p>
<pre><code class="fus-part"><![CDATA[
    statusCode: 404
    message: match <> statusCode >= @0
        600 ? "unsupported"
        500 ? "server error"
        400 ? "client error"
        300 ? "redirect"
        200 ? "success"
        100 ? "informational"
        |     "unsupported"
    # message is "client error"
]]></code></pre>
<p>If using radical mode, the above <code>@0</code> can be simplified to <code>@</code>。</p>
<p><code>else</code> can be combined with a preceding pattern by using <code>or else</code>, but this pattern can't contain <code>then</code>. This is called the combination of <code>else</code> pattern and other pattern, but in essence it's still two patterns. In addition, if <code>or</code> isn't treated as an operator, it can be simplified as <code>,</code>. So the above example can be written as:</p>
<pre><code class="fus-part"><![CDATA[
    message: match <> statusCode >= @0
        600, | "unsupported"
        500  ? "server error"
        400  ? "client error"
        300  ? "redirect"
        200  ? "success"
        100  ? "informational"
]]></code></pre>
<p>When using <code>or else</code> for patterns, <code>or</code> can be omitted. So it can be further simplified to: </p>
<pre><code class="fus-part"><![CDATA[
    message: match <> statusCode >= @0
        600 | "unsupported"
        500 ? "server error"
        400 ? "client error"
        300 ? "redirect"
        200 ? "success"
        100 ? "informational"
]]></code></pre>
<p>Comparison function is very powerful. For example:</p>
<pre><code class="fus-part"><![CDATA[
chessBoard: (pos) -> match <> pos.x = @0.0 and pos.y = @0.1
    [0, 0] ? "king"
    [0, 1] ? "pawn"
    [4, 5] ? "queen"
    |        "empty"
piece: chessBoard {x: 4, y: 5} # will be "queen"
]]></code></pre>
<p>(Note: In radical mode <code>@0.0</code> and <code>@0.1</code> can be simplified to <code>@0</code> and <code>@1</code>.)</p>
<p>Another example:</p>
<pre><code class="fus-part"><![CDATA[
    text: "This is a dog."
    speak: match <> text.includes(@0)
        "cat" ? "meow"
        "dog" ? "woof"
        |       "unknown"
    # speak is "woof"
]]></code></pre>
<p>Once <code>match</code> is followed by a function, it will be recognized as a comparison function. <code>-&gt;</code> or <code>&lt;&gt;</code> must be directly written here. It can't be replaced by a variable.</p>
<p>There are also <code>or</code> pattern and <code>and</code> pattern. <code>or</code> pattern is very commonly used. For example:</p>
<pre><code class="fus-part"><![CDATA[
    day: "Tue"
    action: match day
        "Sat", "Sun" ? "have a rest"
        |              "work"
]]></code></pre>
<p><code>and</code> pattern is less common. But here is an example:</p>
<pre><code class="fus-part"><![CDATA[
    array: ["a", "c", "b", "d"]
    message: match <> array.includes(@0) # note: arr.includes is an ES7 feature
        "a" and "b" and "c" ? "The array includes all of the first 3 letters."
        "a"                 ? "The array includes a."
        "b"                 ? "The array includes b."
        "c"                 ? "The array includes c."
        |                     "The array doesn't include any of the first 3 letters."
]]></code></pre>
<p>From this we know, that the use of <code>or</code> and <code>and</code> as operators are limited within a pattern, for they must be enclosed in a parenthesis pair, otherwise they will be treated as a pattern. But it seems that logical operators are rarely used within patterns.</p>

<p>Like <code>if</code>, in pattern matching <code>then</code> block can be indented. In this way we can omit <code>then</code>:</p>
<pre><code class="fus-part"><![CDATA[
    day: 3
    match day
        6
            go bingo
            go dancing
        7
            go church
        |
            go work
]]></code></pre>
<p>We can find that even when simulating the traditional <code>switch</code>, it's shorter than <code>switch</code>.</p>
<h2>Loop</h2>
<p>In fact, loops violates the idea of functional programming. That's why I deliberately take away loops in FutureScript. But I'm confident that FutureScript can do anything that a loop can do, with the same or shorter length of syntax. (This chapter doesn't belong to the FutureScript specification. It just introduces the <code>loop</code> function in the <code>fus-ext</code> package. This chapter may be outdated. The <code>fus-ext</code> tutorial governs the usage. For convenience, "loop" in this article usually means <code>loop</code>.)</p>
<p>We can use FutureScript's extension package <code>fus-ext</code> to implement loops.</p>
<pre><code><![CDATA[
    npm install fus-ext
]]></code></pre>
<p>Copy <code>node_modules/fus-ext/examples/manifest.fus</code> file to your code's directory.</p>
<p>Your code can be like this:</p>
<pre><code class="fus"><![CDATA[
    fus 2.4.0
    import "./manifest" all

    loop(10, i ->
        console.log "This is \(i) time"
    )
]]></code></pre>
<p>Here we used the "batch import" feature (for details see the "Module" section above). Note that the export of <code>manifest.fus</code> should match the import of yours. If you want to use <code>node</code> instead of <code>es</code>, then you'll need to make corresponding changes in the version line of the two files.</p>
<p>If the iterator returns <code>break</code> then it means to jump out of the loop, similar to JS's <code>break</code>, but different in essence. Here <code>break</code> is an expression, and only capable of cancelling the remaining cycles, not capable of cancelling the remaining part of the function. If <code>break</code> then the <code>loop</code> function returns <code>break</code>。This example is a loop, from 0 to 9, but it will jump out on 5:</p>
<pre><code class="fus-part"><![CDATA[
    loop(10, i ->
        if i < 5
            console.log "This is \(i) time"
        else
            break
    )
]]></code></pre>
<p>If no count is set, it means forever, equivalent to JS's <code>while (true)</code>:</p>
<pre><code class="fus-part"><![CDATA[
    loop --
        if abc()
            break
        else
            doSomething()
]]></code></pre>
<p>This corresponds to JS's <code>for</code> loop, from 1 to 10:</p>
<pre><code class="fus-part"><![CDATA[
    loop{1 to 10 for i ->
        console.log i
    }
]]></code></pre>
<p>This corresponds to JS's <code>for</code> loop, from 10 to 1:</p>
<pre><code class="fus-part"><![CDATA[
    loop{10 to 1 by -1 for i ->
        console.log i
    }
]]></code></pre>
<h2>Recursion</h2>
<p id="45c16ac3-746a-489e-9fd9-be4044b79691">Recursion is not special, but we added some simpler way. You even don't need to name a recursive function. Just think that if it invokes itself, why it must have a name? Just use the <code>fun</code> keyword and it's OK. For example, if you don't want to use an external library, you can simulate a loop using recursion:</p>
<pre><code class="fus-part"><![CDATA[
    do (i: 0) -> if i < 10
        console.log i
        fun(i + 1)
]]></code></pre>
<h2>Exception</h2>
<p>Use <code>try</code>, <code>catch</code>, <code>finally</code> and <code>throw</code>, like CoffeeScript. For example:</p>
<pre><code class="fus-part"><![CDATA[
    try
        checkDirectory()
        writeFiles()
    catch error
        print error
    finally
        cleanUp()
]]></code></pre>
<p><code>throw</code> can even be followed by nothing. If it's in <code>catch</code> block then compiled into <code>throw catchExceptionVar</code>, otherwise compiled into <code>throw undefined</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    try
        doSth()
    catch error
        console.log "error"
        throw # throw error;
]]></code></pre>
<p>When you want to rethrow an exception in <code>catch</code> block, you can type less.</p>
<p id="7e0f8522-9f6b-43e6-ae1b-d16025011688">In essence, <code>try...catch</code> is functional. For example, you can write:</p>
<pre><code class="fus-part"><![CDATA[
    a:
        try
            JSON.parse(x)
        catch
            void
]]></code></pre>
<p class="detail">If <code>try</code> block or <code>finally</code> block is an inline block, then it must occupy the whole line.</p>
<h2 id="358d4ea8-456b-473a-b2d2-8452aaaf4341">Asynchronous</h2>
<p><code>'wait</code> makes an asynchronous function internally synchronous-style, without changing its asynchronous essence. Consider the following JS:</p>
<pre><code class="js"><![CDATA[
    aaa().then(function(x){
        return x.bbb();
    })
    .then(function(x){
        return x.ccc();
    })
    .then(function(x){
        console.log(x);
    });
]]></code></pre>
<p>Now we can write:</p>
<pre><code class="fus-part"><![CDATA[
    do --
        console.log aaa()'wait.bbb()'wait.ccc()'wait
]]></code></pre>
<p>Once the code has <code>'wait</code>, the parent function will be compiled into asynchronous function. We don't need the <code>async</code> keyword, which is totally redundant.</p>
<p><code>'wait</code> must be in a function.</p>
<p><code>'wait</code> is to operate promises. The operand can be a normal promise, or another asynchronous function's return value. The return value of an asynchronous function is also a promise.</p>
<p>Inside an asynchronous function, when executing <code>'wait</code> it will wait until the promise is resolved, then proceed.</p>
<p>An asynchronous function can be called without <code>'wait</code>, if the caller doesn't want to wait for the promise to finish.</p>
<p>An example for using <code>'wait</code> to call an asynchronous function:</p>
<pre><code class="fus-part"><![CDATA[
    do --
        task: --
            aaa()'wait
            bbb()'wait
        task()'wait
        console.log "success"
]]></code></pre>
<p>Without using <code>'wait</code>, it can also be called for the same purpose:</p>
<pre><code class="fus-part"><![CDATA[
    do --
        task: --
            aaa()'wait
            bbb()'wait
            console.log "success"
        task()
]]></code></pre>
<p>Note that if an asynchronous function is called without <code>'wait</code>, then it will return before reaching the first <code>'wait</code> inside the asynchronous function. The following example describes the order:</p>
<pre><code class="fus-part"><![CDATA[
    do --
        task: --
            console.log "stage 1"
            aaa()'wait
            console.log "stage 3"
            bbb()'wait
            console.log "stage 4"
        task()
        console.log "stage 2"
]]></code></pre>
<p>There's one limitation: Because an asynchronous function is compiled into a generator, and the ES6 generator can't contain <code>super</code>, so an asynchronous function can't contain <code>super</code>. It may be solved in later versions, but it requires a huge amount of code to simulate a generator. Surely, it will eventually be solved after ES7 is released, for we can compile it to the native ES7 asynchronous function.</p>
<h1>Object-oriented</h1>
<h2>Class</h2>
<p class="detail">"Field" and "property" of a class are synonyms. A field can be called a "method" if it's a function. Class fields (including static fields) and constructors (including static constructors) are called class members. Note: Class member is conceptually different from object member.</p>
<p>Example:</p>
<pre><code class="fus-part"><![CDATA[
    Cat: class
        new: name ->
            me.name: name
        speak: <>
            console.log me.name + " makes a noise."

    Lion: class from Cat
        speak: <>
            super()
            console.log me.name + " roars."
]]></code></pre>
<p><code>constructor</code> is simplified to <code>new</code>。</p>
<p id="1619f159-69e3-48ae-acb5-ff258e2c3c37">JS's <code>this</code> is replaced by <code>me</code>. We also have another keyword <code>Me</code>, where M is in uppercase, meaning the class of <code>me</code>. When a method is called statically, <code>Me</code> is identical to <code>me</code>, but it's recommended to use <code>Me</code> because it looks more like a class.</p>
<p id="652ac57c-8042-442d-aaa3-8152fe86836f">A highlight of FutureScript's classes is the "anti-conflict field", which is similar to "private field". The benefit of an anti-conflict field is not that the external code can't access it (though can't access it directly by object property). The benefit is that derived classes can safely define a field with the same name, without worrying about the possible conflicts. This is especially important in projects with very complex class structures.</p>
<p>First we look at a negative example. Assuming someone has written a library with an ES6 class in JS:</p>
<pre><code class="js"><![CDATA[
    class User {
        constructor(username) {
            this._name = username;
        }
        getUsername() {
            return this._name;
        }
    }
]]></code></pre>
<p>He has also written an API documentation of how to use <code>User</code>'s constructor and <code>getUsername</code> method. So you write a <code>HumanUser</code> class that inherits <code>User</code> in JS:</p>
<pre><code class="js"><![CDATA[
    class HumanUser extends User {
        constructor(username, name) {
            super();
            this._name = name;
        }
        getName() {
            return this._name;
        }
    }
]]></code></pre>
<p>Because he didn't tell you in documentation which "private fields" he had used, and because your "private field" happens to be <code>_name</code>, your class can't work correctly.</p>
<p>In FutureScript, once a field starts with <code>_</code>, it automatically becomes an anti-conflict field. These 2 classes can be modified as follows in FutureScript:</p>
<pre><code class="fus-part"><![CDATA[
    User: class
        new: username ->
            me._name: username
        getUsername: <>
            me._name
]]></code></pre>
<p>And</p>
<pre><code class="fus-part"><![CDATA[
    HumanUser: class from User
        new: (username, name) ->
            super()
            me._name: name
        getName: <>
            me._name
]]></code></pre>
<p>Why can it avoid conflicts? Because <code>me._name</code> isn't compiled into <code>this._name</code>, but rather compiled into <code>this[_name]</code>, where <code>_name</code> isn't a string but a <code>Symbol</code> instance. Once the compiler goes to <code>me.</code> followed by <code>_</code>, it will compile as such. You can test if you can still access this property using <code>instance._name</code> in JS console.</p>
<p>Anti-conflict fields can also be in the class definition. For example:</p>
<pre><code class="fus-part"><![CDATA[
    Animal: class
        _name: "My Name"
]]></code></pre>
<p>An anti-conflict field can't be enclosed with quotation marks. So, if you want a normal field to start with <code>_</code>, you can write it like <code>me."_name"</code>, therefore it's not an anti-conflict field.</p>
<p>For static fields, we use <code>static</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    Car: class
        static wheelCount: 4
        static energy: "gas"
]]></code></pre>
<p>Anti-conflict fields also apply to static fields. Just rename <code>me.</code> to <code>Me.</code>.</p>
<p id="9861d8b0-8d40-4504-8408-80d9d557cdf0">Like C#, it also supports "static constructor". Just make <code>static</code> followed by nothing. For example:</p>
<pre><code class="fus-part"><![CDATA[
    Website: class
        static: <>
            result: longTimeTask()
            Me.part1: result.0
            Me.part2: result.1
        static ok: <> Me.part1'ok
]]></code></pre>
<p>Equivalent to:</p>
<pre><code class="fus-part"><![CDATA[
    Website: class
        static ok: <> Me.part1'ok
    result: longTimeTask()
    Website.part1: result.0
    Website.part2: result.1
]]></code></pre>
<p>The benefit of a static constructor is that all class-related code can be held inside the class. This looks nicer, brings less typing, and makes variables unexposed.</p>
<p>In static constructors, <code>me.</code> and <code>Me.</code> both mean the class in the closure (i.e. the class itself), not the class of the current object.</p>
<p id="70259430-cb80-46c7-b662-ef56643820a3">C# programmers will not feel strange about getters and setters. We also support them:</p>
<pre><code class="fus-part"><![CDATA[
    Animal: class
        new: <>
            me._name: @0

        name'get: <>
            me._name.toUpperCase()
        name'set: <>
            me._name: @0
]]></code></pre>
<p class="detail">The function of <code>fun</code> can't be a class member.</p>
<p>You don't need to use <code>new</code> when creating instances, because JS's <code>new</code> is redundant - a class isn't useful as a normal function. So, in FutureScript, if a function is recognized as a class, then the function call will automatically have <code>new</code> in generated JS. If not, then it won't have <code>new</code>. The detailed logic is specified by the version line. In rare occasions, a function name of a library may violate the good naming conventions, causing it to be recognized as a class. In this case you can use <code>nonew</code> keyword, which has a similar grammar as <code>new</code>.</p>
<p class="detail">JS supports the form of <code>new new a(b)(c)</code>, but we don't support, because it's too unreadable. You can write as <code>new (new a(b))(c)</code>.</p>
<p>As long as there's a use case for instantiating, you should use a capitalized name for a class, otherwise the compiler will be affected. But if all use cases are static, then you can use any name.</p>
<p><code>Number</code>, <code>String</code>, <code>Boolean</code> and <code>Symbol</code> are always recognized as non-classes, regardless of the version line.</p>
<p>FutureScript classes are ES6 classes, not those represented by a function in ES5 or CoffeeScript. So what's the difference? In ES5 or CoffeeScript, <code>super</code> and <code>this</code> could be in arbitrary order in the constructor of a derived class; But in FutureScript (or ES6) in the constructor of a derived class, <code>me</code> or <code>Me</code> can't be used before <code>super</code>. This is stricter, but in fact it's the same as C# and most mainstream languages. Also it makes this possible: to inherit built-in classes like <code>Array</code> and <code>Error</code>, which is impossible in ES5. (But the problem is that so far only Microsoft Edge fully supports inheriting built-in classes, while other browsers and Node.js still just provide partial support. So now, we can do anything except inheriting <code>Array</code> and <code>Error</code>. But considering ES6 was just released in June 2015, things will change in a few months.)</p>
<p class="detail">For now, in the constructor of a derived class, <code>Me</code> (capitalized) can't be used before <code>super</code>. But when all browsers support <code>new.target</code>, we can support it because it can be compiled to <code>new.target</code>.</p>
<p>But the grammar of FutureScript's <code>super</code> is like CoffeeScript. You don't need to write <code>super.methodName()</code>. Simply use <code>super()</code>. Of course, we also support <code>super.methodName()</code> because this can be used to call a method with a different name. We don't support CoffeeScript's standalone <code>super</code>, but you can use <code>super'(@)</code> or <code>super(@...)</code>.</p>
<p class="detail">We know that generally a constructor doesn't have a return value. But in fact in JS (including ES6), a constructor can have a return value. The return value can be any object, thus you will create an object that's not an instance of the class. This is weird and useless (because this purpose can be achieved by using a static method). So in FutureScript, although constructors can have return values, they almost don't have any effects. What it creates is always an instance of this class.</p>
<p>Do not assign value to a prototype of another object inside a class. For example, this is unreasonable (though it won't raise error):</p>
<pre><code class="fus-part"><![CDATA[
    Website: class
        static: <>
            Abc.prototype.def: <>
                doSomething()
]]></code></pre>
<p>It's because <code>me</code> is bound to the outer class even in the inner <code>prototype</code> function. The correct way is to write it outside the class. Regarding nested classes, they will work as expected, because the compiler can recognize the <code>class</code> keyword and then interpret <code>me</code> correctly. But nested classes are not very useful. It's suggested that classes be flat.</p>
<h1>Using External Libraries</h1>
<h2 id="0262e17a-facd-431e-94c8-2779b4c9ab0a">Pipe</h2>
<p>If you have used the library "underscore", you must be familiar with this code:</p>
<pre><code class="js"><![CDATA[
    var _ = require("underscore");
    console.log(_.max(_.map([3, 4, 5], function(x){return x * 2;})));
]]></code></pre>
<p>Pipe operator is <code>|></code>. It can adjust the order to a natural order, so it can be written as:</p>
<pre><code class="fus-part"><![CDATA[
    console.log [3, 4, 5] |> _.map(x -> x * 2) |> _.max
]]></code></pre>
<p>Note, that because of the precedence, you should avoid using space function call in pipe. For example, the above code can't be written as:</p>
<pre><code class="fus-part"><![CDATA[
    console.log [3, 4, 5] |> _.map x -> x * 2 |> _.max
]]></code></pre>
<p>Another operator is <code>::</code>, called "fat dot", used specifically in pipe expressions. If you want to use pipe along with dots, then fat dot brings more readability. For example:</p>
<pre><code class="fus-part"><![CDATA[
    [3, 4, 5] |> _.map(x -> x * 2) :: map(x -> x + 1) |> _.max
]]></code></pre>
<p>Equivalent to:</p>
<pre><code class="fus-part"><![CDATA[
    (([3, 4, 5] |> _.map(x -> x * 2)).map(x -> x + 1)) |> _.max
]]></code></pre>
<p>So basically a fat dot is equal to a normal dot, except that it acts as an ending tag when it's on the right side of the pipe operator. Also, it is as "fat" as the pipe operator, so looks better.</p>
<p>The code using pipe can be in either compatible mode or radical mode. But if an external library is also written in FutureScript, then this external library should better be written in comptatible mode, because the functions in it must take multiple arguments because pipe itself is to split arguments.</p>
<h2 id="fd221fe8-2827-4c16-8947-b35900b3b050">Virtual Method</h2>
<p>The dot-dot <code>..</code> method can be treated as a virtual method. Its use case is similar to pipe, but makes it even easier to use underscore:</p>
<pre><code class="fus-part"><![CDATA[
    ..: <> _
    console.log [3, 4, 5]..map(x -> x * 2)..max()
]]></code></pre>
<p>Equivalent to JS's:</p>
<pre><code class="js"><![CDATA[
    console.log(_.max(_.map([3, 4, 5], function(x){return x * 2;})));
]]></code></pre>
<p>You can mix dot-dot with dot, where dot is the object's native method. For example:</p>
<pre><code class="fus-part"><![CDATA[
    [3, 4, 5]..map(x -> x * 2).map(x -> x + 1)..max()
]]></code></pre>
<p>The second <code>map</code> is <code>Array</code>'s native method.</p>
<p>To assign to <code>..</code> you can use colon or <code>as</code>.</p>
<p>It supports exporting or importing <code>..</code>, therefore you can put it into your manifest module for batch import, so that you don't need to assign to <code>..</code> in each file. For example you can write in your "manifest.fus":</p>
<pre><code class="fus-part"><![CDATA[
    _: import "underscore"
    ..'export: <> _
]]></code></pre>
<p class="detail">All valid forms of import and export apply to <code>..</code> as well. For example:</p>
<pre class="detail"><code class="fus-part"><![CDATA[
    ..: import "foo"
]]></code></pre>
<p class="detail">Or:</p>
<pre class="detail"><code class="fus-part"><![CDATA[
    import "foo" as ..
]]></code></pre>
<p>The value assigned to <code>..</code> must be a function. This seems redundant but makes it stronger, for you can set different libraries for different types. Therefore, a library can truly become a "virtual method" of a certain class. There won't be any conflict even if there're duplicate function names in two libraries. For example:</p>
<pre><code class="fus-part"><![CDATA[
    ..: x ->
        if x is String
            require("lodash")
        else
            require("underscore")
]]></code></pre>
<p class="detail">When <code>..</code> acts as an operator, it must be followed by a letter, <code>_</code> or <code>$</code>.</p>
<h1>Other Features</h1>
<h2 id="7122051a-71aa-45e4-9af3-79271969be81">do</h2>
<p><code>do</code> is a shorthand for <code>(...)()</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    do --
        console.log "This will be displayed immediately."
]]></code></pre>
<p>Equivalent to:</p>
<pre><code class="fus-part"><![CDATA[
    (--
        console.log "This will be displayed immediately."
    )()
]]></code></pre>
<p>The features are a little less, but purer than CoffeeScript's <code>do</code>. It can be used to:</p>
<ul>
    <li>Represent a recursion that should run immediately.</li>
    <li>Restrict the scope of a variable to avoid conflicts.</li>
    <li>Wrap code to increase readability.</li>
</ul>
<p>Which CoffeeScript feature is missing in FutureScript? See this CoffeeScript code：</p>
<pre><code class="coffee"><![CDATA[
    for button in buttons
        do (button) ->
            button.onclick = ->
                console.log button.textContent
]]></code></pre>
<p>Using <code>do</code> to "hold" a variable name is not supported, because we strictly prohibit same-name variables in different levels. But now it seems there's no need to support it, because we have a better way:</p>
<pre><code class="fus-part"><![CDATA[
    buttons.forEach button ->
        button.onclick: --
            console.log button.textContent
]]></code></pre>
<p>Or:</p>
<pre><code class="fus-part"><![CDATA[
    buttons.every button ->
        button.onclick: --
            console.log button.textContent
        true
]]></code></pre>
<p>This is where the functional style surpasses loops.</p>
<p>But what's the difference between <code>forEach</code> and <code>every</code>? This is beyond this specification but important so I want to point it out. These 2 are ES5 methods. When using <code>forEach</code>, you can't simulate <code>break</code>. But when using <code>every</code>, you can neatly simulate <code>break</code> - just let it return <code>false</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    range.every i ->
        console.log i
        i < 5 ? true | false
]]></code></pre>
<p>We can also replace the <code>true</code> and <code>false</code> with the shorter <code>1</code> and <code>0</code>:</p>
<pre><code class="fus-part"><![CDATA[
    range.every i ->
        console.log i
        i < 5 ? 1 | 0
]]></code></pre>
<p class="detail">Although <code>do</code> can't hold a variable name like CoffeeScript, you can reach the target by naming it differently:</p>
<pre class="detail"><code class="fus-part"><![CDATA[
    do --
        btn: button
        btn.onclick: --
            console.log btn.textContent
]]></code></pre>
<p class="detail">But the problem is that we don't have native loops, so this example is useless.</p>
<p><code>do</code> must be followed by a function literal. This is stricter than CoffeeScript.</p>
<h2 id="cc452c6d-d76a-4836-b9ff-0617b74d5d34">Existence</h2>
<p>These keywords or symbols are about "existence": <code>'ok</code>, <code>ifvoid</code>, <code>ifnull</code>.</p>
<pre><code class="fus-part"><![CDATA[
    a'ok # a !== undefined && a !== null
]]></code></pre>
<p><code>a'ok</code> means <code>a</code> isn't <code>void</code> or <code>null</code>.</p>
<p><code>ifnull</code> and <code>ifvoid</code> have two forms respectively. One is for expression and the other is for colon assignment. For example:</p>
<pre><code class="fus-part"><![CDATA[
    a ifnull: 8 # if (a === null || a === undefined) {a = 8;}
    a ifvoid: 8 # if (a === undefined) {a = 8;}
    b: a ifvoid 8 # b = a !== undefined ? a : 8;
]]></code></pre>
<p class="detail">When used in colon assignment, for now we don't support they coexist with <code>[...]</code>, <code>,</code> or <code>'export</code>. For example, these are illegal:</p>
<pre class="detail"><code><![CDATA[
    a, b ifnull: 1
    [a, b] ifvoid: [1, 2]
    a'export ifnull: 1
]]></code></pre>
<h2>Variant</h2>
<p>You've already seen many apostrophes. These are called variants. Now let's gather them together.</p>
<p>There are 2 forms: unary <code>'</code> and binary <code>'</code>. Unary <code>'</code> is the function's single-argument variant. Others are all binary <code>'</code>.</p>
<p class="detail">How does the compiler determine if a <code>'</code> is unary or binary? It checks the character immediately after <code>'</code>. If it's a number or letter, it's binary; otherwise (e.g. a symbol, space or nothing at all) it's either unary or a parsing failure.</p>
<p class="detail">So these two are the same:</p>
<pre class="detail"><code class="fus-part"><![CDATA[
    a'ok
    a 'ok
]]></code></pre>
<p class="detail">But this is different:</p>
<pre class="detail"><code class="fus-part"><![CDATA[
    a' ok
]]></code></pre>
<p class="detail">For readability, a unary<code>'</code> can't be preceded by a space. So this is illegal:</p>
<pre class="detail"><code><![CDATA[
    a ' ok
]]></code></pre>
<p class="detail">A line can't start with <code>'</code>. So this is illegal (but may be illegal in future versions):</p>
<pre class="detail"><code><![CDATA[
    a
    'ok
]]></code></pre>
<p class="detail">For now there can be at most two <code>'</code> before the colon.</p>
<h2 id="3d5383b2-f689-49fc-ad1f-693030300f9e">in</h2>
<p><code>in</code> is almost the same as CoffeeScript. Of course we don't support <code>!in</code>, but you can use <code>... not in ...</code> or <code>not ... in ...</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    2 in [1, 2, 3] # returns true
    4 in [1, 2, 3] # returns false
    4 not in [1, 2, 3] # returns true
    not 4 in [1, 2, 3] # returns true
]]></code></pre>
<h2 id="208ce2a3-d863-45af-81e1-5c2d573bd28e">is</h2>
<p><code>is</code> means the left side is of the right side type, similar to JavaScript's <code>instanceof</code> but a little different. It can also check primitive types. So it's a mix of <code>instanceof</code> and <code>typeof</code>. If the right side is <code>Number</code>, <code>Boolean</code>, <code>String</code> or <code>Symbol</code> (must be verbatim, not a reference), it will use <code>typeof</code>.</p>
<pre><code class="fus-part"><![CDATA[
    a is A # a instanceof A
    a is Number # typeof a === "number"
]]></code></pre>
<p>Similar to <code>in</code>, to negate it you can use <code>not is</code>, but it's recommended to use the good-looking <code>isnt</code>. You can even use <code>is not</code>.</p>
<pre><code class="fus-part"><![CDATA[
    a isnt A
    a not is A
    not a is A
    a is not A
]]></code></pre>
<p>These 4 behaves the same. You might ask if <code>a is not A</code> is ambiguous. No, because <code>a is (not A)</code> is meaningless - a boolean isn't a class.</p>
<h2>delete</h2>
<p><code>delete</code> is a bit different from JS. It's no longer an expression. This is because in JavaScript strict mode <code>delete</code> will never be <code>false</code>, but will instead throw an error. Since we always use strict mode, there's no need to make it an expression.</p>
<h2>rem, mod</h2>
<p><code id="7f0551f5-957f-4921-ba69-1cabef57f5d8">rem</code> (remainder) means JS's <code>%</code>. <code id="9fac9a39-2e51-475c-aeb7-6dfebec74886">mod</code> is just another modulo operation, where the result has the same sign as the divisor. If the divisor is positive, it's guaranteed that the result is non-negative. So I think <code>mod</code> can be used more widely than <code>rem</code>. <code>a mod b</code> is equivalent to JS's <code>(a % b + b) % b</code>.</p>
<h2 id="27423eb9-49f7-426a-9517-187a886a940f">Exponentiation</h2>
<p><code>**</code> means exponentiation. For example:</p>
<pre><code class="fus-part"><![CDATA[
    a ** 3 # Math.pow(a, 3)
]]></code></pre>
<h2>+ and - (as sign)</h2>
<p class="detail">The grammar of the unary <code>+</code> and <code>-</code> (treated as sign) is similar to CoffeeScript with slight difference. We require that it must be followed immediately by an operand. If it's followed by a space then it will be treated as the binary addition and subtraction. For example:</p>
<pre class="detail"><code><![CDATA[
    # a is 5. `-2` can't be connected because it is a valid statement.
    # To connect, either add a space or move the `-` to the first line
    a: 5
    -2

    # a is 5 - 2
    a: 5
    - 2

    a: -1 # valid
    a: - 1 # invalid

    a+b # a + b
    a + b # a + b
    a+ b # a + b
    a +b # a(+b)

    # They are all `a + (-b)`.
    a + (-b)
    a+(-b)
    a + -b
    a+ -b

    a+-b # invalid
    a++b # invalid
]]></code></pre>
<p class="detail">If it's not followed by a space, then if it's preceded by a letter, digit, <code>_</code>, <code>$</code>, <code>)</code>, <code>]</code>, <code>}</code>, <code>"</code> or <code>@</code>, then it will be treated as binary, otherwise unary.</p>
<p class="detail">Also, when treated as an operator, <code>+</code>, <code>-</code>, <code>*</code> or <code>/</code> can't be followed immediately by <code>+</code> or <code>-</code>.</p>
<h2>Debug</h2>
<p>Use <code>pause</code> to insert a breakpoint. It's equivalent to JS's <code>debugger</code>. We renamed it to <code>pause</code> because <code>debugger</code> is longer than 7 characters.</p>
<h2>Insert JavaScript</h2>
<p>Use <code>js"</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    hi: js"
        function() {
            return ["Hello", "JavaScript"].join(" ");
        }
    "
]]></code></pre>
<p>It suppresses all features of <code>\</code>. For inline JS, double quotes can't be represented. But you can use apostrophes. If you must use double quotes, use formatted JS like the above example.</p>
<p>To work correctly, the inserted JS must be an expression as a whole, such as JS function expression, JS assignment expression. This acts the same as CoffeeScript.</p>
<p>Because it must be an expression as a whole, the outermost level can't contain semicolons. For example you can write this:</p>
<pre><code class="fus-part"><![CDATA[
    js"
        (function() {
            a = 1;
            b = 2;
        })()
    "
]]></code></pre>
<p>But you can't write this:</p>
<pre><code class="fus-part"><![CDATA[
    js"
        a = 1;
        b = 2;
    "
]]></code></pre>
<h1>All Together</h1>
<h2>Keywords</h2>
<ul style="font-family: monospace;">
    <li>above</li>
    <li>and</li>
    <li>as</li>
    <li>catch</li>
    <li>class</li>
    <li>delete</li>
    <li>do</li>
    <li>else</li>
    <li>export</li>
    <li>false</li>
    <li>finally</li>
    <li>fun</li>
    <li>if</li>
    <li>ifnull</li>
    <li>ifvoid</li>
    <li>import</li>
    <li>in</li>
    <li>is</li>
    <li>isnt</li>
    <li>match</li>
    <li>me</li>
    <li>Me</li>
    <li>mod</li>
    <li>new</li>
    <li>nonew</li>
    <li>not</li>
    <li>null</li>
    <li>or</li>
    <li>pause</li>
    <li>rem</li>
    <li>self</li>
    <li>super</li>
    <li>then</li>
    <li>throw</li>
    <li>true</li>
    <li>try</li>
    <li>void</li>
</ul>
<h2>Naming Restrictions</h2>
<p>A variable name can't be a keyword. A variable name can be a JS keyword (as long as it's not a FutureScript keyword). For example, <code>function</code> and <code>instanceof</code> can be variable names.</p>
<p>In class definition, a property name, if not enclosed with double quotes, can't be <code>new</code> or <code>static</code>. Note that <code>static</code> isn't a keyword. <code>new</code> isn't a keyword in class definition (i.e. followed by a colon).</p>
<p>Object literal's property name doesn't have any restrictions.</p>
<p>Of course, if not enclosed with double quotes, the above names must meet the identifier restriction, that is: each character must be a letter, digit, <code>_</code> or <code>$</code>, and it doesn't start with a digit.</p>
<h2>Symbols</h2>
<ul style="font-family: monospace;">
    <li>-&gt;</li>
    <li>&lt;&gt;</li>
    <li>--</li>
    <li>:</li>
    <li>(</li>
    <li>)</li>
    <li>.</li>
    <li>[</li>
    <li>]</li>
    <li>{</li>
    <li>}</li>
    <li>#</li>
    <li>###</li>
    <li>"</li>
    <li>v"</li>
    <li>r"</li>
    <li>js"</li>
    <li>,</li>
    <li>@</li>
    <li>+</li>
    <li>-</li>
    <li>*</li>
    <li>/</li>
    <li>**</li>
    <li>=</li>
    <li>/=</li>
    <li>≠</li>
    <li>&lt;</li>
    <li>&gt;</li>
    <li>&lt;=</li>
    <li>≤</li>
    <li>&gt;=</li>
    <li>≥</li>
    <li>|&gt;</li>
    <li>?</li>
    <li>;</li>
    <li>::</li>
    <li>|</li>
    <li>'</li>
    <li>\</li>
    <li>\(</li>
    <li>'wait</li>
    <li>'ok</li>
    <li>'get</li>
    <li>'set</li>
    <li>'export</li>
    <li>&lt;&lt;</li>
    <li>&gt;&gt;</li>
    <li>...</li>
</ul>
<h2>Operator Precedence</h2>
<p class="detail">The result of an operation is an expression, but an operator isn't always an expression. It can be a block or a non-value thing. Not all operators have precedence. Those whose operands must occupy all the remaining area of the line (unless using <code>&lt;&lt;</code> and <code>&gt;&gt;</code>) don't have precedence, for example <code>match</code> and <code>class</code>. Postfixed <code>if</code> also doesn't have precedence. In the following table, <code>a</code>, <code>b</code>, <code>c</code> mean expression operands; <code>m</code>, <code>n</code> mean block operands; <code>x</code>, <code>y</code>, <code>z</code> mean operands that's not always expressions or blocks.</p>
<p>Note: Precedence is ordered from lowest to highest. In references of other languages they are all from highest to lowest, but I think it's improper for this language because from the functional (recursive) point of view, it should be from "big" (low) to "small" (high). As for associativity, we are also opposite to the traditional way. The traditional table shows the order of execution, but our table shows the order of parsing (to be more accurate, parsing recursively). That is: If executed from left to right, because the right side is "bigger", it's defined as from right to left, simplified as "right"; If executed from right to left, because the left side is "bigger", it's defined as from left to right, simplified as "left". For example, <code>1 + 2 + 3</code> is parsed as <code>plus(plus(1, 2), 3)</code>, and the bigger is shown first. In brief, you can just think we show everything in reverse order in the table.</p>
<table class="table">
    <tr>
        <th>Precedence</th>
        <th>Operator type</th>
        <th>Examples</th>
    </tr>
    <tr>
        <td rowspan="3">0 left</td>
        <td>Arrow Function</td>
        <td><code>x -&gt; m</code></td>
    </tr>
    <tr>
        <td>Diamond Function</td>
        <td><code>&lt;&gt; m</code></td>
    </tr>
    <tr>
        <td>Dash Function</td>
        <td><code>-- m</code></td>
    </tr>
    <tr>
        <td>1 left</td>
        <td>Conditional</td>
        <td><code>if a then m else n<br/>a ? m | n</code></td>
    </tr>
    <tr>
        <td rowspan="3">2 left</td>
        <td>Space Function Call</td>
        <td><code>a b</code></td>
    </tr>
    <tr>
        <td>Space new</td>
        <td><code>new a b</code></td>
    </tr>
    <tr>
        <td>Space nonew</td>
        <td><code>nonew a b</code></td>
    </tr>
    <tr>
        <td>3 right</td>
        <td>or</td>
        <td><code>a or b</code></td>
    </tr>
    <tr>
        <td>4 right</td>
        <td>and</td>
        <td><code>a and b</code></td>
    </tr>
    <tr>
        <td>5 left</td>
        <td>not</td>
        <td><code>not a</code></td>
    </tr>
    <tr>
        <td rowspan="6">6 right</td>
        <td>Equality</td>
        <td><code>a = b</code></td>
    </tr>
    <tr>
        <td>Inequality</td>
        <td><code>a /= b</code></td>
    </tr>
    <tr>
        <td>Less Than</td>
        <td><code>a &lt; b</code></td>
    </tr>
    <tr>
        <td>Less Than Or Equal</td>
        <td><code>a &lt;= b</code></td>
    </tr>
    <tr>
        <td>Greater Than</td>
        <td><code>a &gt; b</code></td>
    </tr>
    <tr>
        <td>Greater Than Or Equal</td>
        <td><code>a &gt;= b</code></td>
    </tr>
    <tr>
        <td rowspan="4">7 right</td>
        <td>in</td>
        <td><code>a in b</code></td>
    </tr>
    <tr>
        <td>Negative in</td>
        <td><code>a not in b</code></td>
    </tr>
    <tr>
        <td>is</td>
        <td><code>a is b</code></td>
    </tr>
    <tr>
        <td>Negative is</td>
        <td><code>a isnt b</code></td>
    </tr>
    <tr>
        <td rowspan="2">8 right</td>
        <td>Addition</td>
        <td><code>a + b</code></td>
    </tr>
    <tr>
        <td>Subtraction</td>
        <td><code>a - b</code></td>
    </tr>
    <tr>
        <td rowspan="4">9 right</td>
        <td>Multiplication</td>
        <td><code>a * b</code></td>
    </tr>
    <tr>
        <td>Division</td>
        <td><code>a / b</code></td>
    </tr>
    <tr>
        <td>Remainder</td>
        <td><code>a rem b</code></td>
    </tr>
    <tr>
        <td>Modulo</td>
        <td><code>a mod b</code></td>
    </tr>
    <tr>
        <td>10 left</td>
        <td>Exponentiation</td>
        <td><code>a ** b</code></td>
    </tr>
    <tr>
        <td rowspan="2">11 left</td>
        <td>Unary Plus</td>
        <td><code>+a</code></td>
    </tr>
    <tr>
        <td>Unary Negation</td>
        <td><code>-a</code></td>
    </tr>
    <tr>
        <td rowspan="2">12 right</td>
        <td>ifvoid</td>
        <td><code>a ifvoid b</code></td>
    </tr>
    <tr>
        <td>ifnull</td>
        <td><code>a ifnull b</code></td>
    </tr>
    <tr>
        <td rowspan="2">13 right</td>
        <td>as</td>
        <td><code>a as x</code></td>
    </tr>
    <tr>
        <td>export as</td>
        <td><code>a export as x</code></td>
    </tr>
    <tr>
        <td>14 right</td>
        <td>Pipe</td>
        <td><code>a |&gt; b</code></td>
    </tr>
    <tr>
        <td rowspan="9">15 right</td>
        <td>Member Access</td>
        <td><code>a.x<br/>a."x"<br/>a.(b)</code></td>
    </tr>
    <tr>
        <td>Dot Dot Member Access</td>
        <td><code>a..x</code></td>
    </tr>
    <tr>
        <td>Fat Dot Member Access</td>
        <td><code>a :: x</code></td>
    </tr>
    <tr>
        <td>Function Call</td>
        <td><code>a(b)<br/>a[b]<br/>a{x}</code></td>
    </tr>
    <tr>
        <td>new</td>
        <td><code>new a(b)</code></td>
    </tr>
    <tr>
        <td>nonew</td>
        <td><code>nonew a(b)</code></td>
    </tr>
    <tr>
        <td>Variant</td>
        <td><code>a'x</code></td>
    </tr>
    <tr>
        <td>Function Variant</td>
        <td><code>a'</code></td>
    </tr>
    <tr>
        <td>import</td>
        <td><code>import "x"</code></td>
    </tr>
</table>
<h2>FAQ</h2>
<p class="question">Q: CoffeeScript has <code>return</code>, but FutureScript goes so far as to drop the <code>return</code>?</p>
<p>A: <code>return</code> is a jump statement, which functional style should avoid. Many functional languages, like F#, don't have <code>return</code>. F# has loops, but doesn't have the <code>break</code> statement that can jump out of the loop. Just like that people all think C's <code>goto</code> is evil because <code>goto</code> is jumping. Although <code>return</code> is only able to jump out, not jump freely, so it's not as evil as <code>goto</code>, but I think it's better to be pure in the beginning period of FutureScript. In fact it's very easy to reach the same target. For example you want to write:</p>
<pre><code><![CDATA[
    x ->
        if x isnt Number return
        x * 2
]]></code></pre>
<p>But now you can write:</p>
<pre><code class="fus-part"><![CDATA[
    x ->
        if x isnt Number
            void
        else
            x * 2
]]></code></pre>
<p>If you don't like more lines, you can write:</p>
<pre><code class="fus-part"><![CDATA[
    x ->
        x isnt Number ? void |
            x * 2
]]></code></pre>
<p>The benefit of this way is that the structure is clearer. As long as it doesn't throw error, the exit of the function is always one: the bottom.</p>
<p class="question">Q: Why are there no bitwise operators?</p>
<p>A: First, FutureScript is a high-level language, so there is no need to support them. Second, JavaScript's bitwise operations are specifically targeted towards 32-bit numbers, which is unreasonable.</p>
<p class="question">Q: Why are there no generators?</p>
<p>A: Generators are suited for specialized uses, the general applications are limited. As for shortening the number of lines of code? Adding a framework can achieve this goal, why do we need to modify the language? As for applications to asynchronous operations, FutureScript already has better methods for dealing with them.</p>
<p class="question">Q: Why must the indent inside a formatted string be greater than the indent of the quotation marks? Can't they be equal?</p>
<p>A: If we allow it to be equal or smaller, this can lead to compilation errors, if some line within the string happens to start with a quotation mark.</p>
<p class="question">Q: Why are there diamond functions in addition to arrow functions?</p>
<p>A: My objective was to eliminate the parentheses around the arguments that are found in CoffeeScript. But if there are no parentheses then it can lead to ambiguity. So I came up with this solution, if you do not add parenthesis, then there must be one argument. But what about the case when there are zero arguments? So I made another symbol. As for multiple arguments, you must add parentheses, but multiple arguments are not in my ideal (radical mode) concept, so this is also acceptable. There is another reason, which is that CoffeeScript's use of the arrow to indicate a function with zero arguments is awkward and misleading, as with arrows it feels like there should be something on the left.</p>
<p class="question">Q: Why doesn't radical mode get rid of the arrow? There is also <code>@</code> available for use.</p>
<p>A: In radical mode, under most conditions there is no need to give arguments names, but if you have multiple levels of functions, when the inner function is using outer arguments, you need to name the arguments.</p>
<p class="question">Q: Why are there no reserved words?</p>
<p>A: Many languages have many reserved words, but I think that if you try to predict future features when you design the language, then you might not predict them correctly. In FutureScript, the version number achieves the goal of "safety", because so long as you do not change the version number, there will not be any compatibility issues.</p>
<p class="question">Q: Not supporting <code>var</code> is inspired by CoffeeScript, but why not support ES6's <code>let</code> and <code>const</code>？</p>
<p>A: My idea is, a programmer might not be familiar with the files outside the one he is currently developing, but he is usually familiar with other parts of the file. <code>let</code> provides block-level safety, but so long as you are familiar with the block, you can use a different variable name. Block-level safety is too small, function-level safety is already strong enough. Otherwise the language complexity will increase. <code>let</code> also conflicts with CoffeeScript's style. Furtheremore, that's because we currently compile variables to <code>var</code>. I thought of compiling all variables to <code>let</code>, but considering code like this:</p>
<pre><code class="fus-part"><![CDATA[
    if x > 0
        a: 1
        b: 2
        c: 3
    else
        a: 4
        b: 5
        c: 6
    console.log(a + b + c)
]]></code></pre>
<p>If we compile to <code>let</code>, then this code will be incorrect, we must assign values to <code>a</code>、<code>b</code>、<code>c</code> at the top for it to work. So I think that it is better to compile to <code>var</code>.</p>
<p>As for<code>const</code>, I think that the idea has a problem, <code>const</code> just applies to constants, and making it such that some things cannot change is not to prevent us from modifying them, but rather to prevent others from modifying them. Normally you make a library, and when others use it, at runtime they might change the internal logic. Variables are visible to just yourself, and others cannot modify them, what need is there to make them constants? What you really want to protect are the attributes and methods of objects, and this cannot be accomplished by <code>const</code>. You can use <code>Object.defineProperty</code> to accomplish it. But to achieve this you must alter all objects including built-in objects to make these methods more rigid (i.e. become almost like static programming languages), and this work would take too much time, while the value is questionable, so at the moment it's not done.</p>
<p class="question">Q: Why not support object destructuring assignment and complex array destructuring assignment?</p>
<p>A: Object destructuring assignment is overly complex. They suit some part of human's intuition, but violate other part of human's intuition, causing them to be confused from the start. Complex array destructuring assignment is medium complexity, it may be supported in the future. As for object destructuring assignment, even if supported in the future, the grammar will be changed to be more natural.</p>
<p class="question">Q: Why <code>@</code> means <code>arguments</code>?</p>
<p>A: First the appearance of <code>@</code> resembles an "a". Second, <code>@</code> is the symbol which looks least like a symbol, we will often use an <code>@</code> alone as an expression, so if we use another symbol here, it will not look like an expression, which will look awkward.</p>
<p class="question">Q: Why do multi-argument functions need parentheses? Can't you omit them in CoffeeScript?</p>
<p>A: Multiple arguments need commas, otherwise it is difficult to see what the commas are delimiting, and it will often be unintuitive. Furthermore, compatibility mode is now the default, but because I think that radical mode is more perfect, if we could omit parentheses with multiple arguments, then it would encourage more people to use compatibility mode.</p>
<p class="question">Q: <code>@</code> is handy. If in the context of <code>catch</code> we could also use a symbol that would be great.</p>
<p>A: I originally thought of using a new symbol to indicate a context inside a child statement, not just limited to "catch", but after some thought, I found it's not suitable. When using <code>@</code> you can see very clearly which function corresponds to the <code>@</code>, because function symbols are very easy to identify. But the only characteristic of a child statement is the indent, and we use indents a lot. This symbol's meaning can easily change, causing confusion. If this new symbol is restricted to just "catch", then the applicability is too small.</p>
<p class="question">Q: Why in <code>as</code> we can't use commas to assign a value to multiple identifiers?</p>
<p>A: If supported, expressions like <code>[aaa as a, bbb]</code> can easily become ambiguous.</p>
<p class="question">Q: If we keep versions of the compiler, won't it become increasingly large? Sounds scary!</p>
<p>A: Actually it's not that scary, while building FutureScript I adopted some techniques to ensure that the increase in size is not so large.</p>
<p class="question">Q: Are all the older versions of the compiler really included?</p>
<p>A: We have included as many as possible. But if we discover a security hole in an older compiler version, then we will delete it. If there is no compiler equivalent to that of the code, during compilation there will be a warning, and it will automatically use a newer compiler.</p>
<p class="question">Q: CoffeeScript's chaining method call doesn't need parentheses, why do we need parentheses here?</p>
<p>A: CoffeeScript actually forcibly adds a rule, which breaks the unity of the langauge, and although for some needs the language becomes more concise, but for other needs it becomes more complex. So I decided not to use this method.</p>
<p class="question">Q: Why it's not good for a module to have both default exports and named exports?</p>
<p>A: You may well separate them to two modules, or give the "default export" a name other than <code>default</code> (Actually a default export is one of named exports, with the name <code>default</code>).</p>
<p class="question">Q: Why <code>-&gt;</code> doesn't define <code>@</code>?</p>
<p>A: If arguments have names, using <code>@</code> is unnecessary. This behavior is like the <code>=&gt;</code> function in ES6.</p>
<p class="question">Q: In JS we can use <code>typeof a === "undefined"</code> to check whether a variable is declared without throwing exceptions, but why we can't here?</p>
<p>A: This seems useless. FutureScript's variables are all declared at the top of the function body, so whether a variable is declared isn't dynamic, so this shouldn't be what the runtime should do.</p>
<p class="question">Q: Why the precedence of the exponentiation operator <code>**</code> differs from that in CoffeeScript?</p>
<p>A: Although it's different with CoffeeScript, it's the same as other languages that have this operator, such as F# and the future ES7. CoffeeScript may have considered that if <code>-3 ** 2</code> means -3<sup>2</sup> then it's -9, but this looks strange, unless you add a space so that it's <code>- 3 ** 2</code>, or you use no space so that it's <code>-3**2</code>. But we rarely write this way, not to mention the former conflicts with multiline connection. Another reason is that CoffeeScript makes <code>**</code> special so that it's inconsistent. In fact the precedence of <code>*</code> should be lower by just one level than <code>**</code>, but luckily <code>(-a) * b</code> is always equivalent to <code>-(a * b)</code> so maybe they think it doesn't matter so they didn't adjust.</p>
<p class="question">Q: The precedence of <code>not</code> is greatly lowered. Is it reasonable?</p>
<p>A: This looks more natural and more in line with human reading. I admit that such change has never been done by anybody, so it takes risks. To see if there're counter-examples that supports maintaining the common precedence, I reviewed the source code of GitHub Atom (It's written in CoffeeScript) as well as my own code. I found that almost no <code>not</code> is simpler under the common precedence. This gave me confidence. I think it's very bad to use <code>not</code> in operands in an arithmetic operation such as addition and multiplication. Maybe some people wants to take advantage of this trick, but such code is very unreadable. Good code will not have <code>not a + not b</code>. We shouldn't use such counter-examples. The same goes for <code>=</code>, <code>&lt;</code> and <code>&gt;</code>.</p>
<p class="question">Q: Why use <code>###</code> for comments? Shouldn't it be more concise if's like formatted string?</p>
<p>A: Sometimes we want to suppress a code region by commenting it, in this case we don't want to adjust the indents.</p>
<p class="question">Q: Shouldn't it be better if <code>export {abc}</code> means named export and <code>export abc</code> means default export?</p>
<p>A: Originally I had this idea, but this can lead to ambiguity, for <code>{abc}</code> can also be treated as an object.</p>
<p class="question">Q: Why not support Unicode variable names?</p>
<p>A: We rarely need this. But later versions may support it.</p>
<p class="question">Q: What's the use of <code>above</code> keyword?</p>
<p>A: <code>above</code> was intended to help you read code in special forms, but later I decided to support this "special forms" in future versions, so now <code>above</code> has no effect.</p>
<p class="question">Q: CoffeeScript's <code>?.</code> is very handy. Why Fus used to support the similar <code>'ok.</code> but later dropped it?</p>
<p>A: If support, then consider the following code:</p>
<pre><code><![CDATA[
    if a.b.c'ok.d.e ≠ 3
        foo()
]]></code></pre>
<p>What you really want is to call <code>foo()</code> when <code>'ok</code> and the entire chain isn't <code>3</code>. But in fact, when not <code>'ok</code>, the entire chain is <code>void</code>, which is also not <code>3</code>, so it will also call <code>foo()</code>. So I think this feature can create traps, which isn't perfect.</p>
<p>Another reason is that the original support isn't complete. It has flaws and bugs. To make it complete, the structure of the compiler should be greatly changed. That's a huge task. So it's better drop it for now and change it later if needed.</p>
</body>
</html>
