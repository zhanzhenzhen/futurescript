<!DOCTYPE html>
<html xml:lang="zh-Hans" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Less and more - Lemo语言 0.1.0</title>
    <link rel="stylesheet" href="http://zhanzhenzhen.github.io/essay-themes/base.css" type="text/css" />
    <link rel="stylesheet" href="http://zhanzhenzhen.github.io/essay-themes/simplified-chinese-modern.css" type="text/css" />
    <style type="text/css"><![CDATA[
        html {
            font-size: 13pt;
        }
        body {
            width: 900px;
        }
        table {
            border-collapse: collapse;
        }
        table, td, th {
            border: 1px solid black;
        }
        td, th {
            vertical-align: top;
            text-align: left;
        }
        code {
            font-size: 0.9rem;
        }
        p > code, li > code {
            background-color: rgb(224,224,224);
            padding-left: 0.2em;
            padding-right: 0.2em;
        }
        pre {
            border-left: 0.6em solid rgb(224,224,224);
            padding: 0.25em 1em;
        }
    ]]></style>
    <script src="http://zizisoft.com/doc-html.js" type="text/javascript" />
</head>
<body>
<h1>Less and more - Lemo语言 0.1.0</h1>
<p>詹臻臻 zhanzhenzhen@hotmail.com</p>
<h1>简介</h1>
<p>JavaScript实在是一门很怪的语言。它早年加入了很多无用的功能，不幸的是，出于兼容性考虑，这些功能永远都不能被删掉。另一方面，JavaScript却缺少很多真正有用的功能。当然，刚刚发布的 ECMAScript 6 补足了大部分缺少的东西，但代价是显得臃肿不堪。如果有一门新的语言，它只继承JavaScript最精华的部分呢？JavaScript最精华的部分是什么？有两个：</p>
<ul>
    <li>闭包的思想</li>
    <li>JSON（大括号和中括号分别表示对象和数组非常直观）</li>
</ul>
<p>2009年诞生了CoffeeScript，更改了JavaScript显得不那么协调的语法，取得了巨大的成功，然而仍然留下一些问题：</p>
<ul>
    <li>一些类C语言的语法仍保留着，其实它们的可读性很差，而且形式不完美。</li>
    <li>异步等可以极大简化编程的功能的缺失。</li>
    <li>版本问题。出于兼容考虑，新版本无法做出大的改变，导致进步越来越微小。</li>
</ul>
<p>Lemo语言的第一感，是它有着极其统一的语法：</p>
<ul>
    <li>中括号<code>[</code>、<code>]</code>始终表示数组字面量，大括号<code>{</code>、<code>}</code>始终表示对象字面量。</li>
    <li>成员访问都是用点号<code>.</code>表示，不管是对象成员，还是数组成员（即元素），也不管对象成员名是不是加了引号，都是如此。</li>
    <li>只要是“令左边为右边的值”，不管是对象字面量，还是赋值，都用冒号<code>:</code>。</li>
    <li>没有烦人的<code>==</code>与<code>===</code>，等号<code>=</code>就表示相等。</li>
</ul>
<pre><code><![CDATA[
    a: ["hello", "world"] # var a = ["hello", "world"]
    console.log(a.0, a.1) # console.log(a[0], a[1])

    b: 5
    a.(b): "last" # a[b] = "last"

    c: {scheme: "http"} # var c = {scheme: "http"}
    c.scheme: "https"
    c."content-length": 123 # c["content-length"] = 123
]]></code></pre>
<p>Lemo语言的第二感，是可读性极佳。看这段：</p>
<pre><code><![CDATA[
    a ifnull: 8 # if (a === null || a === undefined) {a = 8;}
]]></code></pre>
<p>CoffeeScript也可以用<code>a ?= 8</code>，然而Lemo的可读性更佳。另外像逻辑运算符，我们也弃用JS中的符号而改用更自然的<code>and</code>、<code>or</code>、<code>not</code>。</p>
<p>Lemo语言的第三感，是能够极大简化你的代码。熟悉JS的程序员都知道异步的语法有多么不自然，但现在我们可以：</p>
<pre><code><![CDATA[
    console.log abc()'wait.def()'wait.ghi()'wait
]]></code></pre>
<p>要知道，promise相对于传统的“恐怖大三角”回调函数已经是一个进步了。但是上面这一行更进一步，它相当于下面这一大段promise：</p>
<pre><code><![CDATA[
    abc().then(function(x){
        return x.def();
    })
    .then(function(x){
        return x.ghi();
    })
    .then(function(x){
        console.log(x);
    });
]]></code></pre>
<p>Lemo语言里面，没有长度超过7个字母的关键字，简洁存在于我们的基因之中。像是：</p>
<ul>
    <li><code>undefined</code>，我们用<code>void</code>代替。</li>
    <li><code>arguments</code>，我们用<code>@</code>代替。<code>@0</code>就表示<code>arguments[0]</code>。@这符号的圆圈里面就是个a，很好记，是不是？</li>
</ul>
<p>Lemo规定代码文件必须在顶端标明该文件适用的Lemo语言版本。我相信，这个方法能一举解决JS和CoffeeScript的版本问题，这是因为，我们的任何版本都包含历史版本的编译器。这意味着，将来的2.0.0包含1.0.0（当然也包含0.1.0）。</p>
<p>为了看懂Lemo代码，还需要额外记住的东西非常少，也就这3个：</p>
<ul>
    <li>JS的<code>a(b)</code>可简化为<code>a b</code>。</li>
    <li><code>**</code>表示幂运算。<code>2 ** 3</code>即为8。</li>
    <li><code>-&gt;</code>、<code>&lt;&gt;</code>、<code>--</code>都表示函数，即JS的<code>function(...){...}</code>。箭头是带形参的，其他两个不带形参（有什么区别后面会说到）。</li>
</ul>
<p>好了，基本上你只要看完了这一章，任何Lemo代码都能看懂，至少也能猜个八九不离十。</p>
<p>这一章的最后，附上一段示例，可以将其粘贴到浏览器上，或在本地运行（输入<code>lemo &lt;filename&gt;</code>）。</p>
<pre><code><![CDATA[
    Lemo 0.1.0

    # Assignment:
    number:   42
    opposite: true

    # Conditions:
    number: -42 if opposite

    # Functions:
    square: <> @0 ** 2

    # Arrays:
    list: [1, 2, 3, 4, 5]

    # Objects:
    math: {
        root:   Math.sqrt
        square: square
        cube:   <> @0 * square @0
    }

    # Existence:
    alert "I knew it!" if elvis'ok

    # Array comprehensions:
    cubes: list.map <> math.cube @0
]]></code></pre>
<p>如果你不仅想看懂，而且想写Lemo代码，那么请看完余下的章节。</p>
<h1>代码结构</h1>
<h2>文件格式与外观</h2>
<p>后缀名为.lemo。</p>
<p>Lemo文件的外观：由版本行、语句、注释和无语义空白组成。语句是可以嵌套的。版本行和语句是有语义的，注释和无语义空白都是无语义的。</p>
<p>语句不是表达式，也不可以作为表达式。表达式不是语句，但可以作为语句，作为语句时称作表达式语句。有两种语句：表达式语句和命令语句。</p>
<p>类似CoffeeScript，在Lemo中，缩进是很重要的，它构成了嵌套。缩进可以用<code>&lt;&lt;</code>与<code>&gt;&gt;</code>代替。</p>
<p>类似CoffeeScript，多个并列的行可以通过分号<code>;</code>合并，单行可以通过<code>\</code>拆分成多行。</p>
<p>空行，是指不含有字符的行。</p>
<p>空白行，是指不含有字符或只含有空白字符的行。</p>
<p>无语义空白，是指空白行，或者行右侧无意义的空白。</p>
<p>下文的所有描述，都是假设代码中的无语义空白已被去除。</p>
<p>大多数语句都是表达式语句，除了这些是命令语句：</p>
<ul>
    <li>:（冒号，表示赋值时）</li>
    <li>delete</li>
    <li>import（但不包括既没冒号，也没as，也没all的import）</li>
    <li>export（仅限于语句开头是export，所以不包括export as，但包括export...as）</li>
    <li>throw</li>
    <li>pause</li>
</ul>
<p>给定一条语句，该语句所在级别的最大范围连续内容称作该语句所在的块，块不包括版本行。除了块以外，还有表，块和表合称“容器”。块的子项可以是语句或注释，表的子项不可以是语句。我们说某语句的子块（或子表），是指该语句的一级下属。我们说某块的子语句，也是指该块的一级下属。</p>
<p>这些容器是块：</p>
<ul>
    <li>顶级块</li>
    <li>函数块</li>
    <li>then块</li>
    <li>else块</li>
    <li>try块</li>
    <li>catch块</li>
    <li>finally块</li>
</ul>
<p>其他容器则都是表，例如：</p>
<ul>
    <li>class表</li>
    <li>数组表</li>
    <li>对象表</li>
    <li>match表</li>
</ul>
<p>当块（除catch块外）只含有单条语句时，也可以写在一行里而不使用缩进，这称为内联块。例如：</p>
<pre><code><![CDATA[
    if x = 5 then aaa()
]]></code></pre>
<p>注意此时<code>aaa()</code>仍然是属于then块的。另请注意，这种写法中，块之前必须有相应的关键字或符号，例如上例中的<code>then</code>不能省略。由此可知，所有的块（除后置if中的块外），语法里都有关键字或符号作为前导，例如<code>-&gt;</code>、<code>then</code>、<code>try</code>，当这个前导不处于语句头部且不处于行的头部且后面不是内联块时才可能允许省略（还要看语法是否支持，例如<code>-&gt;</code>就不能省略）。</p>
<p>块的子语句是从上往下执行。除顶级块外所有块都有值，若最后一个子语句是表达式，则为该表达式的值，若不是，则为<code>void</code>。</p>
<h2>缩进</h2>
<p>对于某一行B，若它的起始部分不属于字符串，它的缩进的效果是什么？依下面的步骤：</p>
<p>1. 强制连接：上一行A以<code>\</code>结尾吗？若否，则做下一步。若是，则执行：无论缩进如何，该行被解析为犹如被连接到上一行末尾并跳到5，若无法解析则跳到6。（术语解释：这些步骤中的“连接”指的是两行相连，中间插入一空格。第二行的缩进不算入字符。）</p>
<p>2. 并列：上面存在一行A，满足B的缩进等于A的缩进，且A和B之间无其他行或A和B之间的所有行的缩进都大于B的缩进，且A没有被连接或被强制连接（术语解释：“被连接者”是指连接后的右面，“连接者”是指左面）吗？若否，则做下一步。若是，则执行：A的起始部分和B的起始部分被解析为并列关系并跳到5，若无法解析则跳到4。</p>
<p>3. 层级：上面存在一行A，满足B的缩进大于A的缩进，且A和B之间无其他行或A和B之间的所有行的缩进都大于B的缩进，且A没有被连接或被强制连接吗？若否，则做下一步。若是，则执行：A的结尾部分和B的起始部分被解析为层级关系并跳到5，若无法解析则跳到4。</p>
<p>4. 连接：上面存在一行A，满足B的缩进不小于A的缩进，且A和B之间无其他行或A和B之间的所有行的缩进都大于B的缩进吗？若否，则跳到6。若是，则执行：B被解析为犹如被连接到A的末尾所属语句的末尾并跳到5，若无法解析则跳到6。例如：</p>
<pre><code><![CDATA[
    if x = 5 and
    y = 5 then aaa()
]]></code></pre>
<p>或：</p>
<pre><code><![CDATA[
    if x = 5
    and y = 5 then aaa()
]]></code></pre>
<p>或：</p>
<pre><code><![CDATA[
    if x = 5 and
        y = 5 then aaa()
]]></code></pre>
<p>都等价于：</p>
<pre><code><![CDATA[
    if x = 5 and y = 5 then aaa()
]]></code></pre>
<p>又例如：</p>
<pre><code><![CDATA[
    a.b <>
        aaa()
    .c()
]]></code></pre>
<p>等价于：</p>
<pre><code><![CDATA[
    a.b(<> aaa()).c()
]]></code></pre>
<p>5. 解析成功并退出。</p>
<p>6. 解析失败并退出。</p>
<p>缩进的规则很适合用来表示一些复杂的语句。例如，你可以这样写：</p>
<pre><code><![CDATA[
    text: "This is a dog."
    speak: match (<>
        s = @toLowerCase()
        text.includes(s)
    )
        "cat" ? "meow"
        "dog" ? "woof"
        |       "unknown"
    # speak is "woof"
]]></code></pre>
<p>和CoffeeScript有一点不同，如下代码：</p>
<pre><code><![CDATA[
    a.b aaa
    .c()
]]></code></pre>
<p>CoffeeScript编译成<code>a.b(aaa).c()</code>，但我们还是按常规编译成<code>a.b(aaa.c())</code>。如果你想要达到CoffeeScript的效果，要加上括号：</p>
<pre><code><![CDATA[
    a.b(aaa)
    .c()
]]></code></pre>
<h2>&lt;&lt;和&gt;&gt;</h2>
<p>通常来说，把一行拆成几行会增加可读性。但有的时候恰恰相反，你会发觉把几行特别短小的代码合并成一行反而更好看，特别是当你有很多这样的“几行”的时候。例如：</p>
<pre><code><![CDATA[
    A: class << aaa: 1 >>
    B: class << bbb: 1 >>
    C: class << ccc: 1 >>
    D: class << ddd: 1 >>
    E: class << eee: 1 >>
]]></code></pre>
<p>和这个做对比：</p>
<pre><code><![CDATA[
    A: class
        aaa: 1
    B: class
        bbb: 1
    C: class
        ccc: 1
    D: class
        ddd: 1
    E: class
        eee: 1
]]></code></pre>
<p>这时<code>&lt;&lt;</code>和<code>&gt;&gt;</code>的威力就体现出来了。<code>&lt;&lt;</code>表示接下去的代码缩进一级，<code>&gt;&gt;</code>表示还原。</p>
<p><code>&lt;&lt;</code>和<code>&gt;&gt;</code>必须在1行内结束。也就是说，只能把多行合并成1行，无法把多行合并成2行。</p>
<p>这两个符号和分号、逗号结合使用，可以达到最大程度的合并效果。分号合并行，但对象属性、数组元素、类属性需要用逗号合并。</p>
<p>在<code>&gt;&gt;</code>后可加分号或逗号，也可不加分号或逗号，例如：</p>
<pre><code><![CDATA[
    A: class << aaa: x -> << x + 1 >>, bbb: 3 >>
    if aaa << task1() >> else << task2() >>; commonTask()
]]></code></pre>
<p>这里的分号和逗号都是可略的。</p>
<h2>版本行</h2>
<p>每个文件的第一行必须是版本行。版本行通常都写成一行，但写成多行也是允许的，但为了方便说明，还是说成“版本行”。版本行的一般语法：</p>
<pre><code><![CDATA[
    [...][lemo][...] [-]0.1.0[, (radical | compatible) | (capitalized new | manual new) | (node import | node export | node module | es module)]...
]]></code></pre>
<p>默认值为：</p>
<pre><code><![CDATA[
    compatible, capitalized new, es module
]]></code></pre>
<p>版本号后面的以逗号分隔的项不可重复。版本行的例子：</p>
<pre><code><![CDATA[
    0.1.0
    lemo 0.1.0
    lemo -0.1.0
    0.1.0, node module
    0.1.0, compatible, capitalized new
    0.1.0, compatible, capitalized new, node import
    0.1.0, radical, manual new
]]></code></pre>
<p>版本号必须写上。只要你写的版本号不大于安装的Lemo的版本号，该文件就会按照该版本的规范来运行，这是因为你安装的任何一个版本的Lemo都包括了（至少我们会尽量包括）所有历史版本的编译器。而这，是Lemo和其他语言的不同之处。你甚至可以在一个项目中，不同文件使用不同版本。</p>
<p>写上版本号还有个好处，就是你把某个文件交给别人时，他就知道文件是什么版本的，从而可以更好地修改。</p>
<p>本文只描述一个版本。</p>
<p>当你想把版本行写成多行时，版本号后面要加上大括号，大括号必须在第一行。版本号和大括号之间可以有逗号，也可以没有逗号。例如：</p>
<pre><code><![CDATA[
    0.1.0 {
        radical
        node module
    }
]]></code></pre>
<p>多行应用于Shebang的例子（在Shebang中要加选项的话多行是必须的）：</p>
<pre><code><![CDATA[
    #!/usr/bin/env node node_modules/lemo/bin/lemo -0.1.0 {
        radical
        node module
    }
]]></code></pre>
<p>单行应用于Shebang的例子：</p>
<pre><code><![CDATA[
    #!/usr/bin/env node node_modules/lemo/bin/lemo -0.1.0
]]></code></pre>
<p>当文件的后缀名不是.lemo或没有后缀名时，版本号前必须有<code>lemo</code>。当文件的后缀名是.lemo时，不必须，然而我们推荐加上<code>lemo</code>，因为对你的文本编辑器有用，方便它判断应该使用哪个语法包，使代码呈现正确的彩色。</p>
<p>激进模式和兼容模式的差异是：激进模式更鼓励单参数的函数。因此：</p>
<p>激进模式中，<code>@</code>表示JS的<code>arguments[0]</code>。兼容模式中，<code>@</code>表示JS的<code>arguments</code>。</p>
<p>Lemo代码可以被JS调用。JS代码也可以被Lemo调用。</p>
<p><code>capitalized new</code>是指创建类的实例不用加<code>new</code>，编译时会自动加进去，依据类名的首字母大小写，大写的加，小写的不加。能识别的有两种形式：变量和普通的点号（<code>x.y</code>，它会判断<code>y</code>），像<code>x."y"</code>或<code>x.y'</code>是不能识别的。例如：</p>
<pre><code><![CDATA[
    aaa."bbb".Ccc() # new can be omitted
    new aaa.bbb."Ccc"() # new can't be omitted
]]></code></pre>
<p><code>manual new</code>就是传统办法，创建类的实例需要加<code>new</code>。</p>
<p><code>node import</code>是指导入被编译成node的导入（即require）。<code>node export</code>是指导出被编译成node的导出（即exports和module.exports）。<code>node module</code>是两者都做。<code>es module</code>是两者都不做（即按照ES6的规范）。</p>
<p>编译后的代码是strict mode。</p>
<p>本文的示例是按照兼容模式写的，在激进模式下有些地方需要改写。</p>
<h2>注释</h2>
<p>使用<code>#</code>（内联）和<code>###</code>（格式），基本和CoffeeScript完全一样。但有一点不同，CoffeeScript的<code>###</code>是统统编译，我们的<code>###</code>是仅当起始的<code>###</code>紧接在版本行下面（或两者之间只有空白）并且结尾的<code>###</code>右边没有任何非空白时才编译，否则编译器自动忽略。为了和JS兼容，注释中的<code>*/</code>会编译成两个空格。</p>
<h1>基本语句</h1>
<h2>函数</h2>
<p>函数的声明有3种方式：<code>-&gt;</code>、<code>&lt;&gt;</code>、<code>--</code>。<code>&lt;&gt;</code>和<code>--</code>是无参数时的简便方法。参数为1个时括号可省略，这有别于CoffeeScript。</p>
<pre><code><![CDATA[
    # both are valid
    a: x -> x + 1
    a: (x) -> x + 1
]]></code></pre>
<p>如果没有参数，那么必须使用如下一种：</p>
<pre><code><![CDATA[
    a: <> Math.random()
    a: -- Math.random()
    a: () -> Math.random()
]]></code></pre>
<p>允许多参数，但必须要有括号：</p>
<pre><code><![CDATA[
    a: (x, y) -> x * y
]]></code></pre>
<p>单参数如果是数组的话，可以使用类似解构赋值的形式：</p>
<pre><code><![CDATA[
    a: [x, y] -> x * y
]]></code></pre>
<p>注意，当传递的参数不是数组时（例如是<code>void</code>），或者传递的参数个数为零时，它不会出错，而是将x和y都设为<code>void</code>。其实从用途上来说，多参数能达到的，这个也能达到，而且更纯粹，所以，在激进模式中，我们不鼓励使用多参数（多参数在激进模式中功能不全，无法用<code>@</code>表示第一个参数之后的参数）。</p>
<p>在<code>&lt;&gt;</code>函数内部，可以使用<code>@</code>。<code>@</code>取代了JS的<code>arguments</code>（兼容模式下）或<code>arguments[0]</code>（激进模式下），它是如此简便，在许多情况下，你会喜欢不带参数名。例如，我们可以写：</p>
<pre><code><![CDATA[
    add: <> @0 + @1
    console.log add(2, 3) # output 5
]]></code></pre>
<p>参数可以有默认值：</p>
<pre><code><![CDATA[
    a: (x ifvoid: 0, y ifvoid: 0) -> x * y
]]></code></pre>
<p>有默认值的话，哪怕只有一个参数，外面也必须有括号（或中括号）。</p>
<p>如果是<code>ifvoid</code>默认，则<code>ifvoid</code>可以省略，所以上面的例子也等同于：</p>
<pre><code><![CDATA[
    a: (x: 0, y: 0) -> x * y
]]></code></pre>
<p><code>&lt;&gt;</code>和<code>--</code>的区别是：<code>&lt;&gt;</code>只是没有形参，<code>--</code>是既没形参也没实参，当然严格来讲可以传递实参，但不会有任何效果，因为<code>--</code>没有定义<code>@</code>。<code>--</code>里面可以出现<code>@</code>，但是是指外层<code>&lt;&gt;</code>函数的<code>@</code>。<code>--</code>也没有定义<code>fun</code>，<code>--</code>里面可以出现<code>fun</code>，但是是指外层<code>-&gt;</code>或<code>&lt;&gt;</code>函数。<code>--</code>基本可以看成是<code>() -&gt;</code>的简写，但在<code>fun</code>上面有所不同。</p>
<table>
    <tr>
        <th></th>
        <th>-&gt;</th>
        <th>&lt;&gt;</th>
        <th>--</th>
    </tr>
    <tr>
        <td>形参</td>
        <td>有</td>
        <td>无</td>
        <td>无</td>
    </tr>
    <tr>
        <td>@</td>
        <td>无</td>
        <td>有</td>
        <td>无</td>
    </tr>
    <tr>
        <td>fun</td>
        <td>有</td>
        <td>有</td>
        <td>无</td>
    </tr>
    <tr>
        <td>功能</td>
        <td>较多</td>
        <td>最多，可以模拟其他两个</td>
        <td>少</td>
    </tr>
    <tr>
        <td>简洁</td>
        <td>较简洁</td>
        <td>通常很简洁，但有时不简洁</td>
        <td>很简洁</td>
    </tr>
</table>
<p>内层参数不能和任何外层参数重名。这比CoffeeScript、JS都严格。但不排除在以后版本中放开这个限制。</p>
<p>函数的调用有4种表示法：空格、小括号、中括号、大括号。</p>
<pre><code><![CDATA[
    a(2)
    a 2 # equivalent to above
    a[3, 4, 5] # a([3, 4, 5])
    a{prop: true} # a({prop: true})
    a(3, 4, 5) # only valid in compatible mode
]]></code></pre>
<p>多参数调用一定要加括号，这个CoffeeScript不同。只有单参数调用是可以不加括号的，零参数要加<code>()</code>。</p>
<p>CoffeeScript里面如果函数调用要传递的参数本身也是函数的话，如果它没有参数，那么可写成<code>abc -&gt; Math.random()</code>，但Lemo中绝对不能这么写，否则编译器会误以为这是一个参数为abc的函数。必须采用如下一种：</p>
<pre><code><![CDATA[
    # pass a function as argument to abc
    abc <> Math.random()
    abc () -> Math.random()
]]></code></pre>
<p>激进模式会不会限制语言的表达力呢？我认为不会，因为我们可以用对象或数组作为参数，就像上面的例子那样，JSON本身已经十分方便了。</p>
<p>我们还可以使用<code>'</code>来达到类似splat的效果：</p>
<pre><code><![CDATA[
    awardMedals' contenders # awardMedals.apply(null, contenders)
]]></code></pre>
<p>这两个是不同的：</p>
<pre><code><![CDATA[
    a{prop: true}.b # a({prop: true}).b
    a {prop: true}.b # a({prop: true}.b)
]]></code></pre>
<p>凡是函数都有一个返回值，值即为函数块的值，所以我们无需使用<code>return</code>。</p>
<p>不像CoffeeScript，我们没有胖箭头<code>=&gt;</code>。我认为JavaScript使<code>this</code>的含义可自定义是一种错误的设计，它应该始终指向当前对象。我们的函数和CoffeeScript的函数的对应关系如下：</p>
<ul>
    <li>类的方法和构造器（包括嵌套的类的方法和构造器）：CoffeeScript瘦箭头</li>
    <li>类的方法和构造器内部（不包括嵌套的类的方法和构造器，但包括嵌套的类的方法和构造器内部）：CoffeeScript胖箭头</li>
    <li>其余地方：CoffeeScript瘦箭头</li>
</ul>
<h2>赋值与声明</h2>
<p>用<code>:</code>、<code>as</code>。例如：</p>
<pre><code><![CDATA[
    a: "hello world" # var a = "hello world";
    3 as b = 4 ? alert "impossible!" # var b; if ((b = 3) === 4) {alert("impossible");}
]]></code></pre>
<p>注意，<code>:</code>不构成表达式，但<code>as</code>构成表达式。例如：</p>
<pre><code><![CDATA[
    abc: <> a: 1
]]></code></pre>
<p>执行<code>abc()</code>返回的值是<code>void</code>而不是<code>1</code>。但</p>
<pre><code><![CDATA[
    abc: <> 1 as a
]]></code></pre>
<p>执行<code>abc()</code>返回的值是<code>1</code>。</p>
<p>变量不用声明也不能声明，这是因为我们为变量赋值的机制类似CoffeeScript（但有着显著的区别）。CoffeeScript是：如果前面还未出现过则会编译成声明并赋值，如果已出现过则会编译成单纯赋值。Lemo是：如外层没有该变量名，则编译成声明并赋值；如外层有该变量名，则编译成单纯赋值。</p>
<p>考虑如下CoffeeScript代码：</p>
<pre><code><![CDATA[
    ->
        a = 5
    a = 3
]]></code></pre>
<p>CoffeeScript编译成两个重名变量<code>a</code>。然而在Lemo中如果你写：</p>
<pre><code><![CDATA[
    --
        a: 5
    a: 3
]]></code></pre>
<p>会编译成一个变量<code>a</code>。</p>
<p><code>:</code>也支持数组解构赋值（不支持嵌套），例如：</p>
<pre><code><![CDATA[
    [a, b]: [b, a] # swap a and b
]]></code></pre>
<p>冒号的作用就是让左边的拥有右边的值。无论是对象中的冒号还是赋值中的冒号，含义相似。</p>
<p><code>:</code>支持对多标识符同时赋值，例如：</p>
<pre><code><![CDATA[
    a, b: 1 # both a and b are 1
]]></code></pre>
<p>还可以对包含子语句的语句用<code>as</code>，例如：</p>
<pre><code><![CDATA[
    [
        x ->
            aaa(x)
            bbb(x)
            ccc(x)
        as f1

        x ->
            ddd(x)
            eee(x)
            fff(x)
        as f2
    ]
]]></code></pre>
<p>如上例显示，这种<code>as</code>和下一语句之间最好要有空行，不然不容易看清这个<code>as</code>是属于谁的。但我们也提供了你不空行时的好办法，就是加个<code>above</code>。</p>
<pre><code><![CDATA[
    [
        x ->
            aaa(x)
            bbb(x)
            ccc(x)
        above as f1
        x ->
            ddd(x)
            eee(x)
            fff(x)
        above as f2
    ]
]]></code></pre>
<p><code>above</code>对机器来说没有任何意义，不加也是合法的，但对人来说有意义。不过我的看法是，空行更直观些，打起来也更方便。</p>
<p>要注意，上面两个例子中<code>as</code>和上面的函数并不是两个并列的语句，而是一个语句。语句不能以<code>as</code>或<code>above as</code>开头。</p>
<p>只要不是Lemo关键字，就能作为变量名，哪怕是JS关键字如<code>undefined</code>、<code>function</code>也能作为变量名。但JS关键字不能作为全局变量名来赋值或使用。</p>
<h2>模块</h2>
<p>一个文件即是一个模块。和模块有关的语法有<code>import</code>、<code>export</code>、<code>'export</code>。</p>
<pre><code><![CDATA[
    main: import "lib"
]]></code></pre>
<p>或</p>
<pre><code><![CDATA[
    import "lib" as main
]]></code></pre>
<p>都是指导入ES6中的“默认导出”，等同于JS的</p>
<pre><code><![CDATA[
    import main from "lib";
]]></code></pre>
<p>还可以导入所有的“命名导出”：</p>
<pre><code><![CDATA[
    lib: import "lib" all
]]></code></pre>
<p>或</p>
<pre><code><![CDATA[
    import "lib" all as lib
]]></code></pre>
<p>相当于JS的</p>
<pre><code><![CDATA[
    import * as lib from "lib";
]]></code></pre>
<p>还可以导入指定的“命名导出”：</p>
<pre><code><![CDATA[
    {fun1, fun2 as f2}: import "lib"
]]></code></pre>
<p>或</p>
<pre><code><![CDATA[
    import "lib" as {fun1, fun2 as f2}
]]></code></pre>
<p>相当于JS的</p>
<pre><code><![CDATA[
    import {fun1, fun2 as f2} from "lib";
]]></code></pre>
<p>不支持在一个语句里同时导入“默认导出”和“命名导出”，有此需求请分两个语句。我认为一个模块既有“默认导出”又有“命名导出”并不好。</p>
<p>注意，其实上面的一些例子利用了<code>all</code>在用大括号的情况下可省略的特性。如果要写全，应该是：</p>
<pre><code><![CDATA[
    {fun1, fun2 as f2}: import "lib" all
    import "lib" all as {fun1, fun2 as f2}
]]></code></pre>
<p><code>import</code>后面只能跟内联普通字符串，并且字符串里不可以有插值（但可以有转义符）。<code>import</code>不能既有冒号又有<code>as</code>。这些都是正确的import语句：</p>
<pre><code><![CDATA[
    import "./abc" as abc
    abc: import "./abc"
    abc: import "abc" all
    import "abc"
    import "\u0041"
]]></code></pre>
<p>这些是错误的import语句：</p>
<pre><code><![CDATA[
    import("abc")
    import "./a" + "bc" # But this is legal as import expression
    import "./\(filename)"
    import v"abc"
    aaa: import "bbb" as ccc
]]></code></pre>
<p><code>import</code>的赋值不是普通的赋值，它是“绑定”的，和ES6一样。所以，语法上有限制，它只能是赋给变量，不能赋给对象属性，也不能在冒号左边出现<code>ifvoid</code>、<code>ifnull</code>、<code>'</code>。</p>
<p>我们使用node经常碰到这种情况：每个文件开头都有一大堆的导入，基本都重复，但又无法省略。当然，你可以建立一个新模块（即新文件），把这堆东西都放里面，再导出，于是每个模块只要导入这个新模块就可以了。但是，它的代价是，多出了点号。例如，本来是：</p>
<pre><code><![CDATA[
    aaa: import "aaa"
    bbb: import "bbb"
    ccc: import "ccc"
    aaa()
    bbb()
    ccc()
]]></code></pre>
<p>你建一个all.js文件，把这三个<code>import</code>放里面，然后在原文件里写：</p>
<pre><code><![CDATA[
    all: import "./all"
    all.aaa()
    all.bbb()
    all.ccc()
]]></code></pre>
<p>但问题是调用时多出了<code>all</code>，所以似乎也没省多少。</p>
<p>Lemo语言具有独特的“批量导入”功能（ES6中也没有该功能）。当有<code>all</code>但无冒号也无<code>as</code>时便编译成批量导入，它会导入所有的命名导出（但不包括默认导出）并让它们都成为变量名。于是，我们可以写成：</p>
<pre><code><![CDATA[
    import "./all" all
    aaa()
    bbb()
    ccc()
]]></code></pre>
<p>这个功能有个重要特点：编译器生成变量名时，需要读取被导入的模块，为了保证路径解析的方法和运行时一致，我们使解析器尽可能简单，所以只支持以<code>"./"</code>、<code>"../"</code>或<code>"/"</code>开头的路径。所以，这是一个限制，该功能只适合导入同一个项目中的另一个模块，绝不适合用模块名从别的项目中直接导入（就算支持，这也会造成变量名的不确定性）。所以，项目间的导入，一定要在本项目中有一个“清单”模块作为中间模块。</p>
<p>“批量导入”并不引入全局变量，所以不邪恶。这些变量在别的模块中是不可见的，除非别的模块也批量导入了它们。</p>
<p>如果A批量导入B，如果某个B的命名导出（即A中被定义的变量名）恰好是A所在的Lemo版本的关键字，那么该变量将不可用，但不会出错。</p>
<p>被普通导入的模块可以是Lemo文件或JS文件，但被批量导入的模块必须是Lemo文件（版本不限）。</p>
<p>以上介绍的是import语句，import还可以作为表达式，格式是：<code>import "module-name"</code>，后面不能是<code>as</code>，例如：</p>
<pre><code><![CDATA[
    import "abc"
    import "abc" + 1
    a: import "abc" + 1
]]></code></pre>
<p>所以import表达式格式比较自由，但只能导入默认导出，并且如果使用到赋值，那就是普通的赋值，不是绑定的。</p>
<p>导出时，我们可以使用4种语法：<code>export</code>、<code>'export</code>、<code>export as</code>、<code>export ... as</code>。这些都是正确的语法：</p>
<pre><code><![CDATA[
    multiply'export: <> @0 * @1
    mp: (<> @0 * @1) export as multiply
    mp: <>
        @0 * @1
    above export as multiply
    mp: <> @0 * @1
    above export as multiply
    <> @0 * @1
    above export as multiply
    mp: (<> @0 * @1) as multiply'export
    abc export as def
    export abc as def
    export abc
    export: abc # note that this is different from above
    export: <> @0 * @1
]]></code></pre>
<p>和赋值一样，这里的<code>above</code>也是可略的。</p>
<p>这些是错误的语法：</p>
<pre><code><![CDATA[
    abc export def
    export {abc}
    export multiply: <> @0 * @1
    obj.multiply'export: <> @0 * @1
]]></code></pre>
<p>注意<code>abc export as def</code>和<code>export abc as def</code>相似但有着两个区别。一个区别很明显，就是前者是表达式语句而后者是命令语句。另一个区别很微妙，前者的<code>abc</code>是作为表达式，后者的<code>abc</code>是作为变量，这就使得：前者是不绑定的，而后者是绑定的（能享受到ES6模块的变量绑定带来的好处）。</p>
<p>当语句以<code>export:</code>开头，表示ES6中的“默认导出”。文件中这种语句只能出现一次，而且若出现则不能含有其他形式的导出，否则产生编译错误。这是因为如前面提到的，一个模块既有“默认导出”又有“命名导出”不好，虽然出于兼容考虑，Lemo支持导入其他这种架构的模块，但自己的模块就不要使用这种架构了。</p>
<p>默认导出还可以用这种形式：</p>
<pre><code><![CDATA[
    export abc as default
]]></code></pre>
<p>所以默认导出其实是一种特殊的命名导出（详情参见ES6）。当你把它命名为<code>default</code>时即为默认导出。</p>
<p>所以这两个：</p>
<pre><code><![CDATA[
    export abc as default
    export: abc
]]></code></pre>
<p>两者功能相似，唯一的区别是：前者的<code>abc</code>是作为变量，所以是绑定的。后者的<code>abc</code>是作为表达式，所以是不绑定的。（这和ES6的规则相同，ES6的<code>export {... as default}</code>和<code>export default ...</code>也有着上述区别。）</p>
<p>导入和导出必须出现在顶层，因为这是基于ES6的。我们是静态导入，无法动态导入，这比Node要严格。当然，我知道有些场合可能需要动态导入，那你完全可以抛弃Lemo的原生模块语法，而用<code>Node</code>的<code>require</code>。</p>
<h1>数据</h1>
<h2>字符串、正则表达式</h2>
<p>字符串受CoffeeScript启发，不同之处在于不用单引号、不用3个连续引号、不支持字符串的多行自动连接。</p>
<p>内联字符串：</p>
<pre><code><![CDATA[
    str: "Welcome to Lemo!"
]]></code></pre>
<p>格式字符串：</p>
<pre><code><![CDATA[
    htmlStr: "
        <p>
            Welcome to "Lemo"!
        </p>
    "
]]></code></pre>
<p>上例的字符串其实就相当于CoffeeScript的：</p>
<pre><code><![CDATA[
    htmlStr = """
        <p>
            Welcome to "Lemo"!
        </p>
    """
]]></code></pre>
<p>你一定觉得奇怪，为什么我们只需用一个引号就能包住一大段文字（文字本身也有引号），秘密在于我们要求在格式字符串内部，任何行的缩进都必须大于引号的缩进，且起始引号和结束引号的缩进必须相同，所以内部有再多引号也没关系，不影响编译器判断。</p>
<p>格式字符串的起始引号后面必须紧接一换行（这两个换行不算作字符），且结束引号所在的行中，该引号前面必须全是空白。格式字符串的缩进是从字符串内部除空行外缩进最小的一行的缩进的相同值开始算作字符。</p>
<p>格式字符串内部不可以全是空白（但用转义符表示的空白除外）。例如这些都是非法的：</p>
<pre><code><![CDATA[
    str: "
    "

    str: "

    "
]]></code></pre>
<p>这个虽然表示一个空格，但是是允许的：</p>
<pre><code><![CDATA[
    str: "
        \x20
    "
]]></code></pre>
<p>编译器是怎样判断某个引号是内联的还是格式的？看起始引号后面紧接的字符，如果是换行，则为格式，如果是其他字符，则为内联。</p>
<p>我们不用单引号，因为我觉得你要想用单引号，当字符串很长时，你可以用格式<code>"</code>；当字符串很短时，像<code>'"'</code>，这其实只增加了微小的可读性，我宁愿写成<code>"\""</code>。无论哪一种用单引号都没有明显优势，所以，还是别占用宝贵的符号资源为好。而且双引号是和JSON一致的。</p>
<p>也支持字符串插值，就像CoffeeScript，不过我们使用<code>\(...)</code>。</p>
<pre><code><![CDATA[
    str: "Today is \(year)-\(month)-\(day)."
]]></code></pre>
<p>一个插值不能占据多行。目前不支持插值中含有双引号（即字符串嵌套）。其实就算支持，这也会显得太复杂而不美观，完全可以赋值给新变量，再插值。</p>
<p>上面介绍的都是普通字符串。除了普通字符串外，还有特殊字符串和字符串扩展。什么是字符串扩展？正则表达式就是典型的例子。</p>
<p>正则表达式我们用<code>r"..."</code>来表示。例如：</p>
<pre><code><![CDATA[
    str.search(r"^\d{3}-\d{3}-\d{4}$")
]]></code></pre>
<p>内联正则表达式废除了<code>\</code>的大部分功能，除了2个：<code>\"</code>、用于行尾连接的<code>\</code>。注意，JS的正则表达式里的<code>"</code>和<code>#</code>可以直接表示，但在这儿必须用<code>\"</code>和<code>\#</code>，因为这两个字符有特殊含义。</p>
<p>正则表达式可以有插值，插入的是字符串：</p>
<pre><code><![CDATA[
    first: "hello"
    second: "world"
    r"#(first)-#(second)"
]]></code></pre>
<p>和CoffeeScript相同，正则表达式的插值如果是普通字符串的话，如果想用字面量表示<code>\</code>字符，会比较繁琐，所以建议仅把插值用于动态插入非符号字符。</p>
<p>还可以表示带有标志的正则表达式：</p>
<pre><code><![CDATA[
    r"\d{3}-\d{3}-\d{4}"gim
]]></code></pre>
<p>格式正则表达式的例子：</p>
<pre><code><![CDATA[
    str.search(r"
        ^
        \d{3} # first
        -
        \d{3} # second
        -
        \d{4} # third
        $
    ")
]]></code></pre>
<p>格式正则表达式的不同点是：空格和换行无意义，支持注释，表示双引号字符更简单。注释的<code>#</code>左边必须至少有一个空格，这和普通注释不同。</p>
<p>原义字符串是受C#启发。原义字符串用<code>v"..."</code>来表示，例如：</p>
<pre><code><![CDATA[
    path: v"C:\Windows\System"
]]></code></pre>
<p>原义字符串完全废除了<code>\</code>的功能，所以行末不能用<code>\</code>来连接，在内联原义字符串中也无法表示双引号字符。</p>
<p>所以总结一下，凡是字符串起始符号<code>"</code>左边紧接着字母的，可以是表示字符串，也可以表示字符串扩展。</p>
<p>正则表达式引号中间的内容本质上是字符串，这和JS和CoffeeScript都不同。就算是格式正则表达式中的注释，本质上是属于字符串的，只是转换时去掉了而已。注意，转换是运行时而不是编译时，因为可能有插值，所以无法在编译时转换。</p>
<p>还有一点和CoffeeScript不同，就是CoffeeScript中：</p>
<pre><code><![CDATA[
    mobyDick = "Call me Ishmael. Some years ago --
    never mind how long precisely -- having little
    or no money in my purse, and nothing particular
    to interest me on shore, I thought I would sail
    about a little and see the watery part of the
    world..."
]]></code></pre>
<p>这会编译成多行自动连接，连接符是一个空格。但是我们不支持，一个原因是这和我们的格式不兼容，另一个原因是我觉得这只适合西方语言。如果是中文，那加上空格可就错了。所以这个功能不好，应该老老实实用<code>\</code>来连接，是英文的话，前面加个空格。</p>
<p>下表是多种字符串的转义规则（转换时进行的转义不包括在内，如正则表达式语法本身的<code>\</code>）：</p>
<table>
    <tr>
        <th></th>
        <th>内联"</th>
        <th>格式"</th>
        <th>内联v"</th>
        <th>格式v"</th>
        <th>内联r"</th>
        <th>格式r"</th>
        <th>内联js"</th>
        <th>格式js"</th>
    </tr>
    <tr>
        <td>\普通转义符</td>
        <td>有</td>
        <td>有</td>
        <td>无</td>
        <td>无</td>
        <td>无</td>
        <td>无</td>
        <td>无</td>
        <td>无</td>
    </tr>
    <tr>
        <td>\"</td>
        <td>有</td>
        <td>有但不需</td>
        <td>无</td>
        <td>不需且无</td>
        <td>有</td>
        <td>不需且无</td>
        <td>无</td>
        <td>不需且无</td>
    </tr>
    <tr>
        <td>\连接</td>
        <td>有</td>
        <td>有</td>
        <td>无</td>
        <td>无</td>
        <td>有</td>
        <td>有</td>
        <td>无</td>
        <td>无</td>
    </tr>
    <tr>
        <td>插值</td>
        <td>\(...)</td>
        <td>\(...)</td>
        <td>无</td>
        <td>无</td>
        <td>#(...)</td>
        <td>#(...)</td>
        <td>无</td>
        <td>无</td>
    </tr>
</table>
<h2>数组</h2>
<p>方括号的作用就是表示数组或类似数组的东西（用于解构赋值等），没有其他用途。</p>
<p>点号的作用就是访问对象的成员。由于数组也是对象，所以JS中<code>arr[3]</code>我们改为<code>arr.3</code>，更一致。其实数组就是属性名为索引值的对象，刚知道时可能会惊讶，但确实是这样，可以用<code>Object.keys(arr)</code>验证这一论断。JS这点和别的语言不同，但不是糟粕，只要形式上变得一致就可以了。</p>
<p>当然，在和带小数点的数字同时出现时，会感觉别扭，这时建议加上括号。比较一下：</p>
<pre><code><![CDATA[
    x.1 + x.2 + 3.5
    x.(1) + x.(2) + 3.5 # the same as above but looks better
    x1.1 + x1.2 + 2.4
    x1.(1) + x1.(2) + 2.4 # the same as above but looks much better
]]></code></pre>
<p><code>a.(b)</code>等价于JS的<code>a[b]</code>。</p>
<p>数组的表示法和CoffeeScript完全相同。</p>
<h2>对象</h2>
<p>对象的表示法和CoffeeScript基本相同，除了它必须加上大括号，不能省略。</p>
<p>对象成员访问用的是点号，和CoffeeScript基本相同，但如左边是数字，则左边必须加上括号，例如<code>(1).toString()</code>。这个限制是为了防止产生歧义，如<code>1.3</code>，如果没有这个限制就会看上去既像小数又像数组元素访问。当然你可以争辩说其实并没有歧义，因为<code>1</code>不可能是数组，那如果是<code>1.3.a</code>呢？感觉怪怪的，不如<code>(1.3).a</code>直观。所以这一点上我们比JS还严格（JS不允许1.a，但允许1.3.a）。</p>
<h2>字面量</h2>
<p>有这些字面量：</p>
<ul>
    <li>数字字面量</li>
    <li>布尔字面量</li>
    <li>字符串字面量</li>
    <li>字符串扩展字面量</li>
    <li>null字面量</li>
    <li>void字面量</li>
    <li>对象字面量</li>
    <li>数组字面量</li>
    <li>函数字面量</li>
    <li>类字面量</li>
</ul>
<p>字面量都是表达式，但和一般表达式的区别是：</p>
<ul>
    <li>字面量都是常量</li>
    <li>字面量本身不是标识符（但可以含有标识符）</li>
    <li>字面量属于某种特定类型（注意“类型”的范围大于“类”）</li>
    <li>字面量通常是这种特定类型值的创造源头</li>
    <li>字面量有特定的表示法</li>
</ul>
<h2>上下文</h2>
<p>我们有6个关键字或符号表示上下文，分别是：</p>
<ul>
    <li>当前对象：<code>me</code></li>
    <li>当前对象的类：<code>Me</code></li>
    <li>父对象的成员：<code>super</code></li>
    <li>闭包中的当前函数：<code>fun</code></li>
    <li>当前参数：<code>@</code></li>
    <li>赋值中冒号左边的标识符的旧值：<code>self</code></li>
</ul>
<p><code>@</code>后面的点号可以省略，除非点号后面跟<code>(</code>，或者<code>"</code>、<code>v"</code>、<code>r"</code>之类的字符串或字符串扩展。</p>
<h1>控制流</h1>
<h2>逻辑运算</h2>
<ul style="font-family: monospace;">
    <li>=</li>
    <li>/= (not =, not=)</li>
    <li>&lt;</li>
    <li>&gt;</li>
    <li>&lt;=</li>
    <li>&gt;=</li>
    <li>and</li>
    <li>or</li>
    <li>not</li>
</ul>
<p>等号的作用就是判断相等，不用再考虑烦人的<code>=</code>、<code>==</code>、<code>===</code>之间的区别。</p>
<p><code>/=</code>表示不相等，也可写作<code>not =</code>，中间的空白可有可无。为什么我们不用<code>!=</code>？因为感叹号目前Lemo还没用到，我实在不想让一个宝贵的符号只能（或者说，只适合）和等号结合。<code>/=</code>显得也比<code>!=</code>更像<code>≠</code>。</p>
<p>我们暂不支持CoffeeScript风格的链式比较，但以后的版本一定会支持。</p>
<p>Lemo和其他语言在逻辑运算方面最大的区别就是<code>not</code>的优先级。<code>not</code>的优先级被降低，仅高于<code>and</code>和<code>or</code>。这意味着我们可以少加很多括号。你肯定抱怨过在JS中不得不这样写：</p>
<pre><code><![CDATA[
    if !(abc instanceof Abc) doTask();
]]></code></pre>
<p>但现在我们可以：</p>
<pre><code><![CDATA[
    if not abc instanceof Abc
        doTask()
]]></code></pre>
<p>但事实上这个例子是非法的，因为我们没有<code>instanceof</code>关键字，我们是用<code>is</code>关键字，你可以写<code>not abc is Abc</code>但稍显别扭（最好是写成<code>abc isnt Abc</code>）。那有没有好看的例子呢？也有，像这种也不用加上括号：</p>
<pre><code><![CDATA[
    if not 200 <= statusCode < 300
        console.log "failure"
]]></code></pre>
<p>再回到刚才说的不等号。其实还可以用<code>not ... =</code>。这4个功能相同，你看哪个顺眼就用哪个：</p>
<pre><code><![CDATA[
    if statusCode /= 200 throw
    if statusCode not= 200 throw
    if statusCode not = 200 throw
    if not statusCode = 200 throw
]]></code></pre>
<p>不过<code>not ... =</code>虽然功能相同，但生成的代码还是与其他三个不同的。</p>
<h2>条件</h2>
<p>用<code>if</code>、<code>?</code>、<code>then</code>、<code>else</code>、<code>|</code>。例如：</p>
<pre><code><![CDATA[
    b:
        if a = 3
            "three"
        else
            "other"
]]></code></pre>
<p>或</p>
<pre><code><![CDATA[
    b:
        a = 3 ?
            "three"
        else
            "other"
]]></code></pre>
也可以并成一行：
<pre><code><![CDATA[
    b: if a = 3 then "three" else "other"
]]></code></pre>
<p>或</p>
<pre><code><![CDATA[
    b: a = 3 ? "three" else "other"
]]></code></pre>
<p>甚至</p>
<pre><code><![CDATA[
    b: a = 3 ? "three" | "other"
]]></code></pre>
<p><code>?</code>和<code>then</code>等价，<code>|</code>和<code>else</code>等价，这条规则不仅限于<code>if</code>语句，在所有地方通用。下文提到的它们任何一个的规则也适用于它的等价方。</p>
<p>条件前置时，<code>if</code>可写可不写，而<code>then</code>则当<code>then</code>块非内联时可写可不写。<code>if</code>省略时要注意避免出现优先级的问题，例如：</p>
<pre><code><![CDATA[
    a if b > 100 then 100 else b
]]></code></pre>
<p>这里的<code>if</code>省略的话意思就完全不一样了，除非加个括号。</p>
<p>当<code>then</code>后紧接的是表示命令语句的关键字时，<code>then</code>也可省略（这也适用于模式匹配）。例如：</p>
<pre><code><![CDATA[
    if a > 100 throw new Error()
]]></code></pre>
<p>但是要注意，条件前置时无论怎样省略，<code>if</code>和<code>then</code>必须至少出现一个。</p>
<p>如果<code>else</code>块省略，那么则当<code>else</code>时整个<code>if</code>表达式的值为<code>void</code>。</p>
<p>条件还可以后置，这时<code>if</code>就不能省略，例如：</p>
<pre><code><![CDATA[
    alert("a is true!") if a # if (a) {alert("a is true!");}
    mood: "happy" if singing # if (singing) {mood = "happy";}
]]></code></pre>
<p>一条语句中只可以含有一个后置的<code>if</code>，它必须出现在语句的最外层（外面不能有括号），而且<code>if</code>之前不能是普通的块，只能是内联块。由于后置的<code>if</code>只能处于语句的最外层，所以如前面是冒号赋值，那么冒号和<code>if</code>之间的应该属于冒号而不是<code>if</code>。</p>
<p>还有一点和CoffeeScript不同，就是当碰到分号时：</p>
<pre><code><![CDATA[
    if x > 100 then aaa(); bbb()
]]></code></pre>
<p>CoffeeScript是把<code>aaa(); bbb()</code>全作为子语句，这看上去似乎是硬插入一条规则，很不统一，而且我们已有了专门的符号，可以写成：</p>
<pre><code><![CDATA[
    if x > 100 << aaa(); bbb() >>
]]></code></pre>
<p>所以这条规则在我们这里作废。Lemo里，分号的左右两边能在不引发语法错误的前提下穿越一切障碍物。</p>
<h2>模式匹配</h2>
<p><code>match</code>可以看成是一个增强版<code>switch</code>，它称为模式匹配。例如：</p>
<pre><code><![CDATA[
    day: 3
    text: match day
        1 ? "Mon"
        2 ? "Tue"
        3 ? "Wed"
        4 ? "Thu"
        5 ? "Fri"
        6 ? "Sat"
        |   "Sun"
    # text will be "Wed"
]]></code></pre>
<p>上面只是最普通的模式匹配，<code>day</code>是输入，1、2、3……称作模式。</p>
<p>模式匹配中的“比较”默认是用<code>=</code>直接比较输入和模式，<code>match</code>右边还可以不是输入而是比较函数，例如：</p>
<pre><code><![CDATA[
    statusCode: 404
    message: match <> statusCode >= @
        600 ? "unsupported"
        500 ? "server error"
        400 ? "client error"
        300 ? "redirect"
        200 ? "success"
        100 ? "informational"
        |     "unsupported"
    # message is "client error"
]]></code></pre>
<p>注意，上例中的<code>@</code>适用于激进模式，在兼容模式中要改成<code>@0</code>。</p>
<p><code>else</code>可以跟前面的并在一起，此时用<code>or else</code>，但该项不能有<code>then</code>。这称为<code>else</code>模式和其他模式的合并写法，但本质上还是两个模式。在模式匹配中，<code>or</code>这个关键字若不作为运算符使用，可以简写为逗号<code>,</code>，所以上面的例子可以写成：</p>
<pre><code><![CDATA[
    message: match <> statusCode >= @
        600, | "unsupported"
        500  ? "server error"
        400  ? "client error"
        300  ? "redirect"
        200  ? "success"
        100  ? "informational"
]]></code></pre>
<p>用<code>or else</code>的时候<code>or</code>还可以省略，所以还可以写成：</p>
<pre><code><![CDATA[
    message: match <> statusCode >= @
        600 | "unsupported"
        500 ? "server error"
        400 ? "client error"
        300 ? "redirect"
        200 ? "success"
        100 ? "informational"
]]></code></pre>
<p>比较函数的功能非常强大，例如：</p>
<pre><code><![CDATA[
chessBoard: (pos) -> match <> pos.x = @0 and pos.y = @1
    [0, 0] ? "king"
    [0, 1] ? "pawn"
    [4, 5] ? "queen"
    |        "empty"
piece: chessBoard {x: 4, y: 5} # will be "queen"
]]></code></pre>
<p>又如：</p>
<pre><code><![CDATA[
    text: "This is a dog."
    speak: match <> text.includes(@)
        "cat" ? "meow"
        "dog" ? "woof"
        |       "unknown"
    # speak is "woof"
]]></code></pre>
<p>当<code>match</code>后紧接的是函数时，则被识别成比较函数。要直接写出<code>-&gt;</code>或<code>&lt;&gt;</code>，绝不能用变量替代。</p>
<p>还有or模式和and模式。or模式我们会经常用到，例如：</p>
<pre><code><![CDATA[
    day: "Tue"
    action: match day
        "Sat", "Sun" ? "have a rest"
        |              "work"
]]></code></pre>
<p>and模式则不常用，但也有例子：</p>
<pre><code><![CDATA[
    array: ["a", "c", "b", "d"]
    message: match <> array.includes(@)
        "a" and "b" and "c" ? "The array includes all of the first 3 letters."
        "a"                 ? "The array includes a."
        "b"                 ? "The array includes b."
        "c"                 ? "The array includes c."
        |                     "The array doesn't include any of the first 3 letters."
]]></code></pre>
<p>由此可知，or和and作为运算符在模式中使用是有限制的，它作为运算符时必须出现在括号内，否则会被认为是模式。所以真的有这个需求的话，要用个括号包起来。不过它们作为运算符出现在模式中好像也没有什么用。</p>
<p>作为模式使用时要么全是<code>or</code>，要么全是<code>and</code>，两个不能在一个模式中一起出现，否则编译器会无法判断。括号内的无此限制。</p>
<p>注意<code>or else</code>是一种特殊的合并写法，并不属于or模式，所以<code>or else</code>可以和<code>and</code>一起出现。</p>
<p>和<code>if</code>一样，<code>then</code>块可以用缩进，这时就不用写<code>then</code>了：</p>
<pre><code><![CDATA[
    day: 3
    match day
        6
            go bingo
            go dancing
        7
            go church
        |
            go work
]]></code></pre>
<p>可以看出，即便是模拟传统的<code>switch</code>，依然比<code>switch</code>简洁。</p>
<h2>循环</h2>
<p>循环其实并不符合函数式编程的理念，我们没有循环。但我的mate库提供了全局函数repeat来模拟循环。为方便起见，本文中的“循环”一般指repeat。本章不属于Lemo语言规范，只是简要介绍一下repeat函数。例子：</p>
<pre><code><![CDATA[
    repeat[10, i ->
        console.log "This is \(i) time"
    ]
]]></code></pre>
<p>迭代器返回<code>break</code>则表示跳出循环，类似于JS的<code>break</code>，不过本质上不同，这里的<code>break</code>是表达式，只能使余下的循环不做，并不能使函数内剩下的部分不执行。跳出循环时repeat函数返回<code>break</code>。这个例子是一个循环，从0到9，但到5时跳出：</p>
<pre><code><![CDATA[
    repeat[10, i ->
        if i < 5
            console.log "This is \(i) time"
        else
            break
    ]
]]></code></pre>
<p>不设次数则表示永远，相当于JS的<code>while (true)</code>：</p>
<pre><code><![CDATA[
    repeat --
        if abc()
            break
        else
            doSomething()
]]></code></pre>
<p>这个相当于JS的for循环，从10到1：</p>
<pre><code><![CDATA[
    repeat{from: 10, to: 1, by: -1, for: i ->
        alert i
    }
]]></code></pre>
<p><code>by</code>默认为1。</p>
<p>这个有所不同，是从9到0：</p>
<pre><code><![CDATA[
    repeat{count: 10, by: -1, for: i ->
        alert i
    }
]]></code></pre>
<p>Mate随时可能更改，因此本章的内容可能过时。以Mate页面的内容为准：https://www.npmjs.com/package/mate</p>
<h2>递归</h2>
<p>递归的实现方式没有什么特别的，但我们加入了更简便的方法，你甚至无需命名递归函数，你想，自己调用自己，又何必给自己取名字？使用<code>fun</code>关键字就行了。例如，如果你不想用外部库的话，可以用递归模拟循环：</p>
<pre><code><![CDATA[
    do (i: 0) -> if i < 10
        alert i
        fun(i + 1)
]]></code></pre>
<p>Lemo的递归有个好处，它会自动编译（优化）成循环，当自我调用的语句出现在尾部之时。所以，你无需担心堆栈溢出，就算循环1000000次也没关系，编译后的JS代码是一个真正的循环，突破了传统递归的限制。这个在内部是通过Babel实现的。</p>
<h2>异常</h2>
<p>用<code>try</code>、<code>catch</code>、<code>finally</code>、<code>throw</code>，具体实现和CoffeeScript相似。例如：</p>
<pre><code><![CDATA[
    try
        allHellBreaksLoose()
        catsAndDogsLivingTogether()
    catch error
        print error
    finally
        cleanUp()
]]></code></pre>
<p>和CoffeeScript有两点不同。第一：若<code>throw</code>后面啥都没有，不是语法错误，而是：若在catch块内则编译成<code>throw catchExceptionVar</code>，若不在catch块内则编译成<code>throw undefined</code>。第二：<code>try</code>块和<code>finally</code>块若是内联块，则必须占满整行。</p>
<h2>异步</h2>
<p>由于需要尽快促成Lemo面世，我临时决定异步功能不包括在此版本中，但是马上就会在后续版本中实现。</p>
<p><code>'wait</code>类似C#的await，使异步看上去像同步一样（然而不改变其异步的本质），所以它超越了promise。考虑这样一个JS：</p>
<pre><code><![CDATA[
    abc().then(function(x){
        return x.def();
    })
    .then(function(x){
        return x.ghi();
    })
    .then(function(x){
        console.log(x);
    });
]]></code></pre>
<p>我们现在可以写成：</p>
<pre><code><![CDATA[
    do --
        console.log abc()'wait.def()'wait.ghi()'wait
]]></code></pre>
<p>一旦代码有<code>'wait</code>，那么代码所在的函数（直接所在，非嵌套）就被编译成异步函数。我们不用async关键字声明异步函数，这个关键字根本多余。</p>
<p><code>'wait</code>必须出现在函数中。</p>
<p><code>'wait</code>针对的要么是promise，要么是别的异步函数的返回值。异步函数的返回值是被编译成一种特殊的生成器对象，我们将其称为任务。注意，生成器对象不是生成器函数。</p>
<p>在异步函数内部，每执行到<code>'wait</code>，会进入等待，直到该promise或任务有了结果，才继续往下执行。</p>
<p>网上已有文章介绍如何用yield来实现异步，那我们为什么不直接用yield，要发明一个新的符号？因为：</p>
<ul>
    <li>yield的本来意思是“产出”，用来表示异步显得怪怪的。</li>
    <li>yield是前置的，但这里其实应该后置。试想，前面的例子翻译成yield会是什么样？<code>var result = yield (yield (yield abc()).def()).ghi();</code>多层括号，前面3个yield，多难看？而且从时间顺序来说也应该后置。其实C#的await也应该是后置，它也弄得不好。是什么时候wait？是promise函数或异步函数执行完后wait，而不是wait之后再执行。注意promise函数执行完不表示promise有了结果，promise函数本身的执行是同步的。</li>
</ul>
<p>异步和管道结合的例子：</p>
<pre><code><![CDATA[
    do --
        x: data |> lib.process1'wait |> lib.process2'wait
        y: data |> lib.remoteCombine(anotherData1)'wait |> lib.remoteCombine(anotherData2)'wait
        console.log(x, y)
]]></code></pre>
<p>调用异步函数也可以不加<code>'wait</code>，当调用方不需要等待promise或任务出结果的时候。</p>
<p>用<code>'wait</code>调用异步函数的例子：</p>
<pre><code><![CDATA[
    do --
        task: --
            aaa()'wait
            bbb()'wait
        task()'wait
        console.log "success"
]]></code></pre>
<p>不用<code>'wait</code>，也可以调用异步函数并达到相同的目的：</p>
<pre><code><![CDATA[
    do --
        task: --
            aaa()'wait
            bbb()'wait
            console.log "success"
        task()
]]></code></pre>
<p>注意，不用<code>'wait</code>调用异步函数的时候，异步函数执行到第一个<code>'wait</code>的位置之前返回调用方。下面的例子说明了先后顺序：</p>
<pre><code><![CDATA[
    do --
        task: --
            console.log "stage 1"
            aaa()'wait
            console.log "stage 3"
            bbb()'wait
            console.log "stage 4"
        task()
        console.log "stage 2"
]]></code></pre>
<p>其实用<code>'wait</code>调用异步函数的时候也是异步函数执行到第一个<code>'wait</code>的位置之前返回调用方，只不过调用方也在等待，看起来就像没有返回一样。</p>
<p>异步还可以和<code>do</code>结合：</p>
<pre><code><![CDATA[
    largeTask: --

        do --
            aaa()'wait
            bbb()'wait
        'wait

        do --
            ccc()'wait
            ddd()'wait
        'wait

        do --
            eee()'wait
            fff()'wait
        'wait
]]></code></pre>
<h1>面向对象</h1>
<h2>类</h2>
<p>和类有关的关键字有<code>class</code>、<code>super</code>、<code>new</code>、<code>nonew</code>、<code>me</code>、<code>Me</code>。例子：</p>
<pre><code><![CDATA[
    Animal: class
        new: <>
            me.name: @0

        move: meters ->
            alert me.name + " moved \(meters)m."

    Snake: class from Animal
        move: <>
            alert "Slithering..."
            super 5

    Horse: class from Animal
        move: <>
            alert "Galloping..."
            super 45

    sam: Snake "Sammy the Python"
    tom: Horse "Tommy the Palomino"

    sam.move()
    tom.move()
]]></code></pre>
<p>我们使用比传统更纯粹的形式：让赋值功能从class剥离出来，使用表达式而非语句。</p>
<p>类的声明方式比较像CoffeeScript。但我们的更严格。我们多了getter and setter功能，以及<code>constructor:</code>简写成<code>new:</code>。在Lemo中，类的所有声明的子项都必须是以冒号的形式。</p>
<p>JS的<code>this</code>我们用<code>me</code>代替。我们还有一个关键字<code>Me</code>，M大写，表示<code>me</code>所在的类。当静态调用时<code>Me</code>和<code>me</code>相同，但建议使用<code>Me</code>，因为大写比较像类。</p>
<p>getter和setter的例子：</p>
<pre><code><![CDATA[
    Animal: class
        new: <>
            me._name: @0

        name'get: <>
            me._name.toUpperCase()
        name'set: <>
            me._name: @0
]]></code></pre>
<p><code>'get</code>和<code>'set</code>一看就明白。这里的亮点是<code>me._name</code>，它编译成的JS不是像你猜测的那样是<code>this._name</code>，而是<code>this[_name]</code>，其中<code>_name</code>是Symbol。编译器一碰到<code>me.</code>，并且后面是以<code>_</code>开头的话，即这样编译。</p>
<p>这被称作“防冲突字段”，可以把它近似看成是私有字段。防冲突字段的好处不是外部无法访问，外部虽然无法通过对象的属性直接访问，但可以间接访问，最大的好处是继承类可以放心地使用同名的防冲突字段，而不用担心会覆盖，这在类关系很复杂的大型项目中尤其重要。因为这些字段不属于API，通常别的开发者是不会告诉你是怎样用的，如果你继承别人写的类，有可能你的私有字段正好重名，类的行为就被破坏了。</p>
<p>以<code>_</code>开头的字段名还可以出现在字段的声明中，例如：</p>
<pre><code><![CDATA[
    Animal: class
        _name: "My Name"
]]></code></pre>
<p>字段的声明中只要是以<code>_</code>开头的，便自动成为防冲突字段。</p>
<p>防冲突字段不能用引号包起来。所以如果你实在是想让你的普通字段以<code>_</code>开头，就可以写成像<code>me."_name"</code>的形式，这就不是防冲突字段了。</p>
<p>对于对象和类而言，属性、成员、字段是同义词。方法是指为函数的字段。</p>
<p>创建实例时无需使用new，因为其实JS的new是多余的，如果一个函数只能被当作类来使用，肯定会加new。所以在Lemo中，只要这被识别为一个类，那么当被作为函数调用时，编译出来的就会自动加上new。反之，如果不是类，编译出来的就不会加上new。具体的识别方法由版本行指定。当然，罕见的情况下，某个库的函数名可能会不符合约定，造成被识别为类，这时可以用<code>nonew</code>关键字，语法上和<code>new</code>一样。</p>
<p><code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Symbol</code>始终被识别为不是类，无论编译选项如何。</p>
<p>CoffeeScript对于静态字段是使用<code>@property: value</code>，我们使用的是<code>static</code>，即<code>static property: value</code>。</p>
<p>防冲突字段也适用于静态字段，区别是使用的不是<code>me.</code>而是<code>Me.</code>。</p>
<p>Lemo的类属于ES6的类，而不是CoffeeScript的类或ES5中用函数模拟的类。这有什么区别呢？在CoffeeScript中，构造函数里面<code>super</code>和<code>this</code>的位置可以任意；但在Lemo（或ES6）中，构造函数里面<code>me</code>或<code>Me</code>不能出现在<code>super</code>之前。这的确更严格，但其实和C#以及主流编程语言相同，并且使这成为可能：继承<code>Array</code>、<code>Error</code>等内置类，这在ES5时代是不可能的。为什么这种机制可以做到继承<code>Array</code>、<code>Error</code>，限于篇幅不再赘述。但问题是目前只有Microsoft Edge完全支持继承内置类，其余浏览器包括Node.js支持有限。所以目前，我们可以用类做任何事，除了继承<code>Array</code>、<code>Error</code>以外。但考虑到2015年6月ES6才正式发布，形势有望在未来数月内改变，届时就会完美。</p>
<p>但是Lemo中<code>super</code>的语法比较像CoffeeScript，不用写<code>super.methodName()</code>，直接<code>super()</code>即可。我们不支持孤立的<code>super</code>，不过你可以写成<code>super'(@)</code>。</p>
<p>我们知道一般构造函数是没有返回值的，但其实在JS（包括ES6）中，构造函数可以有返回值，可以返回任何对象，这样创造的就不是该类的实例。但这很怪异，没有什么实用价值。所以在Lemo里，构造函数虽然也可以有返回值，但它几乎不起作用，创造的永远是该类的实例。（返回值唯一的用处是使用<code>fun</code>递归时，如果你真的想对构造函数使用递归的话。）</p>
<p>有的时候我们想写静态构造函数，也可以，<code>static</code>后面不要跟任何名称即可，例如：</p>
<pre><code><![CDATA[
    Website: class
        static: <>
            result: longTimeTask()
            Me.part1: result[0]
            Me.part2: result[1]
]]></code></pre>
<p>静态构造函数内的<code>me.</code>和<code>Me.</code>都指向当前闭包所在的类，即这个类本身，而不是当前对象的类。</p>
<p>不要在类的方法或构造器内部为另一个对象的原型方法赋值。例如这样不合理（虽然不会出错）：</p>
<pre><code><![CDATA[
    Website: class
        static: <>
            Abc.prototype.def: <>
                doSomething()
]]></code></pre>
<p>这是因为在该原型方法内使用<code>me</code>的话表示不了你想要表示的东西。正确的方法是把它写在类的外面。至于嵌套类，是可以的，因为编译器能识别<code>class</code>关键字，从而做出对于<code>me</code>的正确解释。不过嵌套类好像用处也不大，建议类与类的关系还是扁平为好。</p>
<p>只要类有实例化需求，就要避免取非大写开头的名称，否则会影响编译器判断。如果类的所有需求都是静态，那么就任意了。</p>
<h1>使用外部库</h1>
<h2>管道</h2>
<p>管道操作符是<code>|></code>。例子：</p>
<pre><code><![CDATA[
    u: import("underscore")
    [3, 4, 5] |> u.map(x -> x * 2) |> u.max
]]></code></pre>
<p>管道使我们使用underscore函数库可以一种人类习惯的顺序来书写，我们再也不用这样写了：</p>
<pre><code><![CDATA[
    u: require("underscore")
    u.max(u.map([3, 4, 5], x -> x * 2))
]]></code></pre>
<p>还有一种运算符<code>::</code>，称之为“胖点”，专门应用于含有管道运算符的表达式，如果你想让管道和点号混合，胖点能提供更强的可读性。例如：</p>
<pre><code><![CDATA[
    [3, 4, 5] |> u.map(x -> x * 2) :: map(x -> x + 1) |> u.max
]]></code></pre>
<p>相当于：</p>
<pre><code><![CDATA[
    (([3, 4, 5] |> u.map(x -> x * 2)).map(x -> x + 1)) |> u.max
]]></code></pre>
<p>所以胖点基本就是点号，只不过我们规定当它出现在管道右边时作为结束标记，而且看起来比较“胖”，和管道运算符比较接近，显得比较舒服。</p>
<p>用到管道的代码可以是兼容模式，也可以是激进模式。但如果管道使用的外部库也用Lemo写的话，还是用兼容模式来写比较好，因为外部库中的函数必须是多参数的，因为管道本身就是分割参数的。</p>
<h1>其他特色</h1>
<h2>do</h2>
<p><code>do</code>是<code>(...)()</code>的简便方法，比CoffeeScript的<code>do</code>功能略少，但更纯粹。它可以用来：</p>
<ul>
    <li>表示立即执行的递归</li>
    <li>限定变量范围，防止冲突</li>
    <li>分隔代码，增加可读性</li>
</ul>
<p>它的功能比CoffeeScript少在哪里？看一段CoffeeScript代码：</p>
<pre><code><![CDATA[
    for button in buttons
        do (button) ->
            button.onclick = ->
                alert button.textContent
]]></code></pre>
<p>这种通过<code>do</code>来hold住一个变量名的方法，由于Lemo实行严格的禁止层级变量重名，所以我们不支持，但是现在看来也无需支持，因为有了更好的方法：</p>
<pre><code><![CDATA[
    buttons.forEach button ->
        button.onclick: --
            alert button.textContent
]]></code></pre>
<p>或：</p>
<pre><code><![CDATA[
    buttons.every button ->
        button.onclick: --
            alert button.textContent
        true
]]></code></pre>
<p>两者有啥区别？这已经超出了本文的范围，不过挺重要的，还是说一下。这两个数组方法都属于ES5规范，当使用<code>forEach</code>时，是无法模拟<code>break</code>的。当使用<code>every</code>时，可以巧妙地模拟<code>break</code>，只需让它返回false即可。例如：</p>
<pre><code><![CDATA[
    range.every i ->
        alert i
        i < 5 ? true | false
]]></code></pre>
<p>也可以不用<code>true</code>、<code>false</code>，而用更短的<code>1</code>、<code>0</code>：</p>
<pre><code><![CDATA[
    range.every i ->
        alert i
        i < 5 ? 1 | 0
]]></code></pre>
<p>当然，<code>do</code>虽然不能像CoffeeScript一样hold住变量名，但你只要取个不一样的名字，就可以达到相同的目的：</p>
<pre><code><![CDATA[
    do --
        btn: button
        btn.onclick: --
            alert btn.textContent
]]></code></pre>
<p>但问题是我们没有原生的循环，所以上面这个例子也没有什么用。</p>
<p><code>do</code>的右面必须紧接函数字面量，这个比CoffeeScript严格。</p>
<h2>存在</h2>
<p>这几个关键字或操作符和“存在性”有关<code>'ok</code>、<code>ifvoid</code>、<code>ifnull</code>。</p>
<p><code>a'ok</code>，意思就是a既不是void，也不是null。</p>
<p><code>'ok</code>还可以和点号结合起来使用，<code>'ok.</code>等同于CoffeeScript的<code>?.</code>，例如这段CoffeeScript</p>
<pre><code><![CDATA[
    zip = lottery.winner?.address?.zipcode
]]></code></pre>
<p>就可以写成：</p>
<pre><code><![CDATA[
    zip: lottery.winner'ok.address'ok.zipcode
]]></code></pre>
<p><code>'ok</code>还可以和函数调用结合起来使用，形式是<code>'ok(...)</code>、<code>'ok[...]</code>或<code>'ok{...}</code>。和CoffeeScript的<code>?(...)</code>一样。例如这段CoffeeScript</p>
<pre><code><![CDATA[
    zip = lottery.drawWinner?().address?.zipcode
]]></code></pre>
<p>就可以写成：</p>
<pre><code><![CDATA[
    zip: lottery.drawWinner'ok().address'ok.zipcode
]]></code></pre>
<p><code>ifnull</code>和<code>ifvoid</code>有两种形式，一种是后面跟冒号，一种是后面不跟冒号。例如：</p>
<pre><code><![CDATA[
    a ifnull: 8 # if (a === null || a === undefined) {a = 8;}
    a ifvoid: 8 # if (a === undefined) {a = 8;}
    b: a ifvoid 8 # b = a !== undefined ? a : 8;
]]></code></pre>
<p>后面跟冒号时，即是赋值，目前暂不支持与<code>[...]</code>、<code>,</code>共存，例如这样是非法的：</p>
<pre><code><![CDATA[
    a, b ifnull: 1
    [a, b] ifvoid: [1, 2]
]]></code></pre>
<h2>'</h2>
<p><code>'</code>的形式有两种，一种是一元<code>'</code>，一种是二元<code>'</code>。一元<code>'</code>即函数的单参数变体。其他的都是二元<code>'</code>。</p>
<p>编译器如何判断某个<code>'</code>是一元还是二元？看<code>'</code>后面紧跟的字符。如果是数字或字母，则是二元，否则（例如是符号、空格或根本没有字符）要么是一元，要么无法解析。</p>
<p>所以这两者是一样的：</p>
<pre><code><![CDATA[
    a'ok
    a 'ok
]]></code></pre>
<p>但这个不一样：</p>
<pre><code><![CDATA[
    a' ok
]]></code></pre>
<p>为了可读性，一元的<code>'</code>前面的那个字符不能是空白。像这个就是非法的，必须无法解析：</p>
<pre><code><![CDATA[
    a ' ok
]]></code></pre>
<p>行不能以<code>'</code>开始。像这个是非法的（在未来版本中可能会合法）：</p>
<pre><code><![CDATA[
    a
    'ok
]]></code></pre>
<p>冒号左边的<code>'</code>目前不能超过2个。</p>
<h2>in</h2>
<p><code>in</code>的用法和CoffeeScript几乎完全相同，当然，不支持<code>!in</code>，可以用<code>... not in ...</code>或<code>not ... in ...</code>。</p>
<h2>is</h2>
<p><code>is</code>表示左边是右边的类型，类似于JavaScript的<code>instanceof</code>，但又有些区别，它还能判断原始类型，可以说结合了<code>instanceof</code>和<code>typeof</code>。当右边是<code>Number</code>、<code>Boolean</code>、<code>String</code>、<code>Symbol</code>（必须严格表示为这4个之中的1个，不能是引用）时使用<code>typeof</code>。</p>
<pre><code><![CDATA[
    a is A # a instanceof A
    a is Number # typeof a === "number"
]]></code></pre>
<p>与<code>in</code>相似，<code>is</code>表示否定时也是可以用<code>not is</code>，不过也可以使用更顺眼的<code>isnt</code>，甚至可以用<code>is not</code>。</p>
<pre><code><![CDATA[
    a isnt A
    a not is A
    not a is A
    a is not A
]]></code></pre>
<p>这4个表达式的功能是一样的。你可能要问，<code>a is not A</code>不会引起歧义吗？不会，因为<code>a is (not A)</code>是无意义的，布尔值不是类。</p>
<h2>delete</h2>
<p><code>delete</code>和JavaScript中的稍有不同。它不再是一个表达式。这是因为在JavaScript strict mode中并没有值为false的情况，而是抛出异常。既然我们都是用strict mode，所以没必要弄成表达式。</p>
<h2>rem和mod</h2>
<p><code>rem</code>即是JavaScript的<code>%</code>。<code>mod</code>是另一种求余，正负号和除数相同，只要除数是正数，结果就不为负，所以这种求余适用范围可能更广一些。<code>a mod b</code>相当于JavaScript的<code>(a % b + b) % b</code>。</p>
<h2>+和-（正负号）</h2>
<p>一元的<code>+</code>、<code>-</code>（正负号）的用法和CoffeeScript相似但有微小区别，我们规定它只能是紧接着算元，如果后面的字符是空白则被当作加号和减号。例如：</p>
<pre><code><![CDATA[
    # a is 5. `-2` can't be connected because it is a valid statement.
    # To connect, either add a space or move the `-` to the first line
    a: 5
    -2

    # a is 5 - 2
    a: 5
    - 2

    a: -1 # valid
    a: - 1 # invalid

    a+b # a + b
    a + b # a + b
    a+ b # a + b
    a +b # a(+b)

    # They are all `a + (-b)`.
    a + (-b)
    a+(-b)
    a + -b
    a+ -b

    a+-b # invalid
    a++b # invalid
]]></code></pre>
<p>如果后面的字符不是空白，则如果前面的字符是字母、数字、<code>_</code>、<code>$</code>、<code>)</code>、<code>]</code>、<code>}</code>、<code>"</code>或<code>@</code>，则被解析为加号和减号，否则被解析为正负号。</p>
<p>另外，作为运算符时，<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>之后不能紧接<code>+</code>或<code>-</code>。</p>
<h2>调试</h2>
<p>使用<code>pause</code>命令插入断点。它等价于JS的<code>debugger</code>命令，因为<code>debugger</code>违反了关键字不能大于7个字符的原则，所以改名为<code>pause</code>。</p>
<h2>插入JavaScript</h2>
<p>使用<code>js"</code>。例如：</p>
<pre><code><![CDATA[
    hi = js"
        function() {
            return [document.title, "Hello JavaScript"].join(": ");
        }
    "
]]></code></pre>
<p>它完全废除了<code>\</code>的功能，双引号也无法在其中用任何变通的办法表示（否则会有代价），不过妙在JS也支持单引号。如果必须用双引号，就用格式。</p>
<p>为了能够正常运行，插入的整体必须是表达式，例如JS函数表达式、JS赋值表达式等。这一点，和CoffeeScript相同。</p>
<h1>汇总</h1>
<h2>关键字</h2>
<ul style="font-family: monospace;">
    <li>above</li>
    <li>and</li>
    <li>as</li>
    <li>catch</li>
    <li>class</li>
    <li>delete</li>
    <li>do</li>
    <li>else</li>
    <li>export</li>
    <li>false</li>
    <li>finally</li>
    <li>fun</li>
    <li>if</li>
    <li>ifnull</li>
    <li>ifvoid</li>
    <li>import</li>
    <li>in</li>
    <li>is</li>
    <li>isnt</li>
    <li>match</li>
    <li>me</li>
    <li>Me</li>
    <li>mod</li>
    <li>new</li>
    <li>nonew</li>
    <li>not</li>
    <li>null</li>
    <li>or</li>
    <li>pause</li>
    <li>rem</li>
    <li>self</li>
    <li>super</li>
    <li>then</li>
    <li>throw</li>
    <li>true</li>
    <li>try</li>
    <li>void</li>
</ul>
<h2>命名限制</h2>
<p>变量名不可以是关键字。变量名可以是JS关键字（只要它不是Lemo关键字即可），例如<code>function</code>、<code>instanceof</code>都可以作为变量名。</p>
<p>类声明中的属性名如不用引号，则不可以是<code>new</code>、<code>static</code>。如用引号，则没有限制。注意，<code>static</code>不是关键字，<code>new</code>用来进行类声明（即后面是冒号）时不是关键字。</p>
<p>对象字面量的属性名没有限制。</p>
<p>当然，不用引号时，以上名称都需要满足标识符约束，即：每个字符都是字母、数字、<code>_</code>或<code>$</code>，且起始字符不是数字。</p>
<h2>符号</h2>
<ul style="font-family: monospace;">
    <li>-&gt;</li>
    <li>&lt;&gt;</li>
    <li>--</li>
    <li>:</li>
    <li>(</li>
    <li>)</li>
    <li>.</li>
    <li>[</li>
    <li>]</li>
    <li>{</li>
    <li>}</li>
    <li>#</li>
    <li>###</li>
    <li>"</li>
    <li>v"</li>
    <li>r"</li>
    <li>js"</li>
    <li>,</li>
    <li>@</li>
    <li>+</li>
    <li>-</li>
    <li>*</li>
    <li>/</li>
    <li>**</li>
    <li>=</li>
    <li>/=</li>
    <li>&lt;</li>
    <li>&gt;</li>
    <li>&lt;=</li>
    <li>&gt;=</li>
    <li>|&gt;</li>
    <li>?</li>
    <li>;</li>
    <li>::</li>
    <li>|</li>
    <li>'</li>
    <li>\</li>
    <li>\(</li>
    <li>'wait</li>
    <li>'ok</li>
    <li>'get</li>
    <li>'set</li>
    <li>'export</li>
    <li>&lt;&lt;</li>
    <li>&gt;&gt;</li>
</ul>
<h2>运算符优先级</h2>
<p>运算符的运算结果是表达式，但算元不一定是表达式，也可以是块，甚至是非值的东西。不是所有运算符都有优先级。算元必须占满该行剩余部分（除非用<code>&lt;&lt;</code>和<code>&gt;&gt;</code>）的运算符（即通常分多行写的）就没有优先级，例如<code>match</code>和<code>class</code>。后置的<code>if</code>也没有优先级。下面表格中，a、b、c表示表达式算元，m、n表示块算元，x、y、z表示不一定是表达式或块的算元。</p>
<p>注意，优先级从低到高。别的语言参考，都是优先级从高到低，但我觉得不妥，因为用函数式（递归）思维来看，应该从“大”（低）到“小”（高）。结合性，我们也和传统的写法相反，传统写的是执行顺序，我们写的是解析顺序（更精确地说是用递归解析的顺序）。即：执行时自左向右的，由于右侧较“大”，我们写为自右向左，简称“右”，而执行时自右向左的，由于左侧较“大”，我们写为自左向右，简称“左”。打个比方，<code>1 + 2 + 3</code>其实是被解析为<code>plus(plus(1, 2), 3)</code>。我们仍然是以大为先。总之这方面大家反着看就行了。</p>
<table>
    <tr>
        <th>Precedence</th>
        <th>Operator type</th>
        <th>Examples</th>
    </tr>
    <tr>
        <td rowspan="3">0 left</td>
        <td>Arrow Function</td>
        <td><code>x -&gt; m</code></td>
    </tr>
    <tr>
        <td>Diamond Function</td>
        <td><code>&lt;&gt; m</code></td>
    </tr>
    <tr>
        <td>Dash Function</td>
        <td><code>-- m</code></td>
    </tr>
    <tr>
        <td>1 left</td>
        <td>Conditional</td>
        <td><code>if a then m else n<br/>a ? m | n</code></td>
    </tr>
    <tr>
        <td rowspan="3">2 left</td>
        <td>Space Function Call</td>
        <td><code>a b</code></td>
    </tr>
    <tr>
        <td>Space new</td>
        <td><code>new a b</code></td>
    </tr>
    <tr>
        <td>Space nonew</td>
        <td><code>nonew a b</code></td>
    </tr>
    <tr>
        <td>3 right</td>
        <td>or</td>
        <td><code>a or b</code></td>
    </tr>
    <tr>
        <td>4 right</td>
        <td>and</td>
        <td><code>a and b</code></td>
    </tr>
    <tr>
        <td>5 left</td>
        <td>not</td>
        <td><code>not a</code></td>
    </tr>
    <tr>
        <td rowspan="6">6 right</td>
        <td>Equality</td>
        <td><code>a = b</code></td>
    </tr>
    <tr>
        <td>Inequality</td>
        <td><code>a /= b</code></td>
    </tr>
    <tr>
        <td>Less Than</td>
        <td><code>a &lt; b</code></td>
    </tr>
    <tr>
        <td>Less Than Or Equal</td>
        <td><code>a &lt;= b</code></td>
    </tr>
    <tr>
        <td>Greater Than</td>
        <td><code>a &gt; b</code></td>
    </tr>
    <tr>
        <td>Greater Than Or Equal</td>
        <td><code>a &gt;= b</code></td>
    </tr>
    <tr>
        <td rowspan="4">7 right</td>
        <td>in</td>
        <td><code>a in b</code></td>
    </tr>
    <tr>
        <td>Negative in</td>
        <td><code>a not in b</code></td>
    </tr>
    <tr>
        <td>is</td>
        <td><code>a is b</code></td>
    </tr>
    <tr>
        <td>Negative is</td>
        <td><code>a isnt b</code></td>
    </tr>
    <tr>
        <td rowspan="2">8 right</td>
        <td>Addition</td>
        <td><code>a + b</code></td>
    </tr>
    <tr>
        <td>Subtraction</td>
        <td><code>a - b</code></td>
    </tr>
    <tr>
        <td rowspan="4">9 right</td>
        <td>Multiplication</td>
        <td><code>a * b</code></td>
    </tr>
    <tr>
        <td>Division</td>
        <td><code>a / b</code></td>
    </tr>
    <tr>
        <td>Remainder</td>
        <td><code>a rem b</code></td>
    </tr>
    <tr>
        <td>Modulo</td>
        <td><code>a mod b</code></td>
    </tr>
    <tr>
        <td>10 left</td>
        <td>Exponentiation</td>
        <td><code>a ** b</code></td>
    </tr>
    <tr>
        <td rowspan="2">11 left</td>
        <td>Unary Plus</td>
        <td><code>+a</code></td>
    </tr>
    <tr>
        <td>Unary Negation</td>
        <td><code>-a</code></td>
    </tr>
    <tr>
        <td rowspan="2">12 right</td>
        <td>ifvoid</td>
        <td><code>a ifvoid b</code></td>
    </tr>
    <tr>
        <td>ifnull</td>
        <td><code>a ifnull b</code></td>
    </tr>
    <tr>
        <td rowspan="2">13 right</td>
        <td>as</td>
        <td><code>a as x</code></td>
    </tr>
    <tr>
        <td>export as</td>
        <td><code>a export as x</code></td>
    </tr>
    <tr>
        <td>14 right</td>
        <td>Pipe</td>
        <td><code>a |&gt; b</code></td>
    </tr>
    <tr>
        <td rowspan="8">15 right</td>
        <td>Member Access</td>
        <td><code>a.x<br/>a."x"<br/>a.(b)</code></td>
    </tr>
    <tr>
        <td>Fat Dot Member Access</td>
        <td><code>a :: x</code></td>
    </tr>
    <tr>
        <td>Function Call</td>
        <td><code>a(b)<br/>a[b]<br/>a{x}</code></td>
    </tr>
    <tr>
        <td>new</td>
        <td><code>new a(b)</code></td>
    </tr>
    <tr>
        <td>nonew</td>
        <td><code>nonew a(b)</code></td>
    </tr>
    <tr>
        <td>Variant</td>
        <td><code>a'x</code></td>
    </tr>
    <tr>
        <td>Function Variant</td>
        <td><code>a'</code></td>
    </tr>
    <tr>
        <td>import</td>
        <td><code>import "x"<br/>import("x")</code></td>
    </tr>
</table>
<h2>常见问题</h2>
<p>问：为啥没有正则表达式符号？</p>
<p>答：正则表达式完全可以用<code>r"</code>来表示。</p>
<p>问：为啥没有位操作符？</p>
<p>答：首先，Lemo作为高级语言，没必要支持。其次，JavaScript的位操作是专门针对32位数字的，这本身就不合理。</p>
<p>问：为啥没有生成器？</p>
<p>答：生成器是适合特定用途的，似乎普适性还不够。至于缩短代码长度？加一个类库也可以达到这个目的，干嘛非得改动语言层面呢？至于在异步操作中的用途，Lemo也已经有了更好的替代方法。</p>
<p>问：为啥格式字符串的缩进必须大于引号处的缩进？等于也不行吗？</p>
<p>答：如果允许等于或小于，就有可能造成编译器误判，当字符串中某行行首正好是引号的时候。</p>
<p>问：为啥函数除了箭头符号以外还要弄个菱形符号？</p>
<p>答：我的目标是消除CoffeeScript中参数两边的括号。但是如果没有括号的话会产生歧义。所以我就想出了这个办法，如果不加括号，那就必须为1个参数。那零个参数怎么办？就再造一个符号呗。至于多个参数，就必须加括号，不过多参数并不在我的理想化（即激进模式）的构想当中，所以这也可以接受。再有一个原因，就是CoffeeScript用箭头表示零参数的话看上去既别扭又误导，箭头嘛，感觉应该左边有东西才对。</p>
<p>问：既然如此，那为啥激进模式不废除箭头符号？反正有<code>@</code>可以用。</p>
<p>答：激进模式中，大多数情况下确实没必要给参数取名，但当你有多层函数，内层调用外层参数的时候，取名就有必要了。</p>
<p>问：为啥没有保留字？</p>
<p>答：很多语言都有很多保留字，但我觉得你设计语言的时候预先定义好未来的功能，那未来有可能是你没料到的。我们在版本行使用版本号，也达到了“安全”的目的，因为可以保证只要你不修改版本号，就不会出现兼容性问题。</p>
<p>问：不支持<code>var</code>是受CoffeeScript启发，但为啥不支持ES6的<code>let</code>和<code>const</code>？</p>
<p>答：我的理念是，一名程序员也许不熟悉正在开发的文件之外的其他文件，但是一般都会熟悉这个文件当中的其他区域。<code>let</code>提供块级的保护，但是只要你熟悉的不是只是这个块，你完全可以使用一个不同的变量名。块级保护太小了，函数级保护已经足够坚固。否则的话语言本身的复杂度也会增加。<code>let</code>和CoffeeScript风格之间也有矛盾。而且我们是编译成<code>var</code>，曾经我想把所有变量编译成<code>let</code>，但是考虑这样的代码：</p>
<pre><code><![CDATA[
    if x > 0
        a: 1
        b: 2
        c: 3
    else
        a: 4
        b: 5
        c: 6
    console.log(a + b + c)
]]></code></pre>
<p>如果是编译成<code>let</code>，那么这段代码是有错的，必须要在顶部给<code>a</code>、<code>b</code>、<code>c</code>赋值才行。所以我觉得还是编译成<code>var</code>好。</p>
<p>至于<code>const</code>，我觉得理念有问题，<code>const</code>只是针对常量而已，而我们让某个东西不可变，不是防自己改，是防别人改。通常是自己做了个库，别人使用时，在运行时可能会乱改内部逻辑。变量仅自己可见，别人改不了，又何必成为常量？真正要保护的其实是对象的属性或方法，这个<code>const</code>却无法做到。可以通过<code>Object.defineProperty</code>来做到。但要动就得动包括原生对象在内的所有的对象，让方法都变得坚固（即变成类似静态语言的样子），这工作量太大了，可行性也值得怀疑，所以目前暂不做。</p>
<p>问：为何不支持对象解构赋值和复杂数组的解构赋值？</p>
<p>答：对象解构赋值过于复杂。它符合了人类一部分直觉，但违反了人类另一部分直觉，导致一开始根本就看不懂。复杂数组的解构赋值是中等复杂，以后也许会支持。至于对象解构赋值，以后即使支持，语法也要改得更自然。</p>
<p>问：为什么arguments用<code>@</code>表示？</p>
<p>答：首先，<code>@</code>形状也像个a。其次，<code>@</code>是符号中看上去最不像符号的，我们经常会使用孤立的<code>@</code>作为一个表达式，这时如果用其他符号，会显得不像个表达式，就不舒服了。</p>
<p>问：为什么以多参数调用函数一定要加括号？CoffeeScript不是可以不加吗？</p>
<p>答：多参数要用到逗号，不加括号的话，逗号到底分隔什么，不容易看清楚，大多数时候违反人类直觉。而且，现在默认是兼容模式，但因为我觉得激进模式更完美，如果多参数可以不加括号，就显得更加鼓励人们采用兼容模式了。</p>
<p>问：<code>@</code>很好用，如果catch的上下文也能用一个符号表示就好了。</p>
<p>答：本来我考虑再用个新的符号来指代子语句内的上下文，不仅限于catch，但想想，不宜。用<code>@</code>时你很容易看清某个<code>@</code>所对应的是哪个函数，因为函数符号很好辨认。但子语句仅有的特征是缩进，而缩进我们是用得非常多的，很容易这个新符号的意思会变来变去，导致你搞混。如果这个新符号仅限于catch，又适用面太小。</p>
<p>问：<code>as</code>为何不能用逗号同时赋值？</p>
<p>答：若支持，像这个表达式<code>[aaa as a, bbb]</code>就容易产生歧义。</p>
<p>问：保留旧版本的编译器，那岂不越来越庞大？好恐怖！</p>
<p>答：其实也没那么恐怖，我们在做Lemo的时候会采取一些手段，使增量不那么大。</p>
<p>问：真的所有旧版本的编译器都包括吗？</p>
<p>答：我们尽量包括。但如果我们发现某个旧版本有安全漏洞，那么我们则会删掉。若不存在与代码相同版本的编译器，编译的时候会出现警告，同时会自动用新版本的编译器编译。</p>
<p>问：CoffeeScript多行链式（chaining）方法调用不用加括号，这里为啥要加括号？</p>
<p>答：CoffeeScript其实是硬生生加了条规则，这会破坏语法的统一，而且虽然在一部分需求中更简洁了，但当有另一部分需求的时候却更复杂了。所以我决定不用这套方法。</p>
<p>问：为啥一个模块既有“默认导出”又有“命名导出”不好？</p>
<p>答：你完全可以分两个模块，或者给“默认导出”取个非default的名字（事实上“默认导出”的确是“命名导出”的一部分，名字是default）。</p>
<p>问：为啥<code>-&gt;</code>函数没有定义<code>@</code>？</p>
<p>答：当你参数有名称时，再用<code>@</code>就显得多余。这时用<code>@</code>唯一的作用就是当函数的参数数量可变时。但是如果你的函数参数数量可变，更好的做法是不设任何形参。也有一种情况是希望后半部分参数数量可变，但是我不太喜欢这样做，我建议把这部分参数弄成一个数组。</p>
<p>问：JS中可以用<code>typeof a === "undefined"</code>检查变量是否已定义又不引发异常，这里为啥做不到？</p>
<p>答：这好像并没有什么用。Lemo的变量统统编译成在函数顶部声明，所以变量的定义与否不是动态的，所以检查这个不应该是程序运行时做的事情。</p>
<p>问：CoffeeScript也有<code>return</code>，Lemo居然没有？</p>
<p>答：<code>return</code>是一种跳跃式语句，函数式风格应该尽量避免这种语句，很多函数式语言，像微软的F#，是没有<code>return</code>的，F#有循环，但是也没有能跳出循环的<code>break</code>命令。就好比现在人们都认为C语言的<code>goto</code>命令是很邪恶的，就是因为<code>goto</code>是跳跃性的。当然<code>return</code>只是跳出而已，不能自由跳跃，远没有<code>goto</code>那么邪恶，但我想，至少在Lemo语言的初创阶段，还是彻底一些好。其实你很容易就可以达到相同的目的。比如你想这样写：</p>
<pre><code><![CDATA[
    x ->
        if x isnt Number return
        x * 2
]]></code></pre>
<p>现在你可以这样写：</p>
<pre><code><![CDATA[
    x ->
        if x isnt Number
            void
        else
            x * 2
]]></code></pre>
<p>如果你嫌行多，可以这样写，也是2行：</p>
<pre><code><![CDATA[
    x ->
        x isnt Number ? void |
            x * 2
]]></code></pre>
<p>这种方式的好处就是结构更清晰，只要不抛出异常，函数的出口永远只有一个，永远在底部。</p>
<p>问：为啥幂运算符<code>**</code>的优先级和CoffeeScript不一样？</p>
<p>答：虽然和CoffeeScript不一样，但是和大多数有这个运算符的语言一样，比如F#，比如未来的ES7草案。CoffeeScript应该是考虑到<code>-3 ** 2</code>如果书写成-3<sup>2</sup>应该是-9，但这看上去非常别扭，除非你加个空格，成为<code>- 3 ** 2</code>，或者干脆都不用空格，成为<code>-3**2</code>，但很少有人会这么写，前者还和多行连接有冲突。另一个原因是，CoffeeScript这样做弄得不大协调，就<code>**</code>显得那么特殊，其实<code>*</code>的优先级理应只比<code>**</code>低一级，只不过<code>(-a) * b</code>恒等于<code>-(a * b)</code>，所以可能他们觉得无所谓就不调整了而已。</p>
<p>问：<code>not</code>优先级被大幅降低，这合理吗？</p>
<p>答：这看上去更自然，更符合人类阅读方式。我承认，这个改变从来没有人做过，具有冒险性。为了看看有没有反例，支持<code>not</code>应该维持目前通用的优先级，我看了GitHub的Atom编辑器的源代码（它是用CoffeeScript编写的），还看了我自己的代码。我发现，几乎没有一处<code>not</code>在目前通用的优先级下更简单的，这给了我信心。因为我的想法是，算术运算符，像加法、乘法，对它们的算元使用<code>not</code>是非常不好的，也许有人会利用这种方式来取巧，但可读性非常差，所以好的代码中是不会出现<code>not a + not b</code>的，这种反例不应该使用。引申到<code>=</code>、<code>&lt;</code>、<code>&gt;</code>也是一样。</p>
<p>问：为啥格式注释是用<code>###</code>？如果像格式字符串一样，不是更简洁吗？</p>
<p>答：有时我们喜欢用注释把一段代码作废，就不可能弄得很整齐。</p>
<p>问：如果<code>export {abc}</code>表示命名导出，<code>export abc</code>表示默认导出不是很好嘛？</p>
<p>答：原先是有这种考虑，但这在将来版本中可能会产生歧义（将来版本中<code>{abc}</code>可能是一个合法的对象）。</p>
<p>问：为啥不支持Unicode变量名（不用引号时）？</p>
<p>答：很少有这种需求，因为加上引号就可以了。不过以后版本中可能会支持。</p>
</body>
</html>
